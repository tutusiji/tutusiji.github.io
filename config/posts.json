{
  "posts": [
    {
      "content": "\r\n一、css3动画\r\n1、css3动画属性介绍\r\n2、动画十四原则\r\n3、动画的历史演变及实践\r\n4、demo演示\r\n5、帧动画、骨骼动画、gif、apng、webp\r\n二、svg动画\r\n1、icon动画\r\n2、SVG SMIL animation\r\n3、SVG + snap.svg.js 实践\r\n三、javasctipt动画\r\n1、脚本dom操作\r\n2、工具\r\n四、canvas动画\r\n1、\r\n五、3D动画\r\n1、Three.js\r\n2、D3.js\r\n3、pixi\r\n六、动画工具\r\nAdobe html5\r\nAbobe flash to html5\r\n\r\n\r\n微众H5\r\nhttp://tuziki.com/demo/webank/mobile/index.html\r\n\r\n摩托车分步解析\r\nhttp://tuziki.com/demo/webank/motorcycle/step/index.html\r\n\r\n单独的摩托车\r\nhttp://tuziki.com/demo/webank/motorcycle/index.html\r\n\r\n动画十四原则\r\nhttp://tuziki.com/demo/animation_principles/demo.html\r\n\r\n企鹅H5\r\nhttp://tuziki.com/demo/q1/html/index.html\r\n\r\n永动企鹅\r\nhttp://tuziki.com/demo/qe/html/index.html\r\n\r\nAnimate.css动画演示\r\nhttps://animate.style/\r\n\r\n定义和用法\r\nanimation 属性是一个简写属性，用于设置六个动画属性：\r\nanimation-name\r\nanimation-duration\r\nanimation-timing-function\r\nanimation-delay\r\nanimation-iteration-count\r\nanimation-direction\r\n\r\nPixi.js\r\nhttp://www.pixijs.com/\r\n\r\n",
      "data": {
        "title": "web动画深入学习",
        "date": "2023-05-07 04:14:48",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "web-dong-hua-shen-ru-xue-xi"
    },
    {
      "content": "https://blog.csdn.net/zhulin2012/article/details/88762136n'g\r\nhttps://blog.csdn.net/juny0302/article/details/105739542\r\nhttps://www.cnblogs.com/37Y37/p/13684415.html\r\nhttps://github.com/miyuesc/bpmn-process-designer\r\nhttps://github.com/LinDaiDai/bpmn-chinese-document",
      "data": {
        "title": "规则引擎",
        "date": "2023-05-07 04:09:58",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gui-ze-yin-qing"
    },
    {
      "content": "![](https://www.tuziki.com/post-images/1683403602870.png)",
      "data": {
        "title": "数据平台流程",
        "date": "2023-05-07 04:06:06",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "shu-ju-ping-tai-liu-cheng"
    },
    {
      "content": "> 来自于2020年7月23日平安智慧城市\\智慧生活事业部\\交付前端组本人的技术分享\r\n\r\n# 小程序设计之初\r\n一般来说，渲染界面的技术有三种：\r\n\r\n+ 用纯客户端原生技术来渲染\r\n+ 用纯 Web 技术来渲染\r\n+ Hybrid 技术\r\n![](https://www.tuziki.com/post-images/1683399206056.png)\r\n\r\n## Hybrid 技术\r\n1. 基于 WebView UI 的基础方案，市面上大部分主流 App 都有采用，例如微信JS-SDK，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予H5一定程度的原生能力。\r\n\r\n2. 基于 Native UI 的方案，例如 React-Native、Weex。在赋予 H5 原生API能力的基础上，进一步通过 JSBridge 将js解析成的虚拟节点树(Virtual DOM)传递到 Native 并使用原生渲染。\r\n\r\n3. 小程序方案，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了UI渲染与JS逻辑，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。\r\n\r\n以上的三种方案，其实同样都是基于 JSBridge 完成的通讯层，第2 、3种方案，其实可以看做是在方案一的基础上，继续通过不同的新技术进一步提高了应用的混合程度。因此，JSBridge 也是整个混合应用最关键的部分，例如我们在设置微信分享时用到的 JS-SDK，wx对象 便是我们最常见的 JSBridge:\r\n\r\n这个方案就是我们所说的 JSBridge，而实现的关键，便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。\r\n\r\n微信分享时用到的 JS-SDK，wx对象 便是我们最常见的 JSBridge:\r\n![](https://www.tuziki.com/post-images/1683399625115.png)\r\n\r\n### 小程序的架构\r\n+ WXML 和 WXSS 工作在渲染层（webview）\r\n+ JS脚本工作在逻辑层（jsCore）\r\n+ 并且每个小程序页面都是对应一个 webview 线程，这样性能比较好\r\n![](https://www.tuziki.com/post-images/1683401285632.png)\r\n>> 相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。\r\n\r\n微信小程序的框架包含两部分View视图层、App Service逻辑层，View层用来渲染页面结构，AppService层用来逻辑处理、数据请求、接口调用，它们在两个线程里运行。 \r\n\r\n视图层使用WebView渲染，逻辑层使用JSCore运行。 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。\r\n```html\r\n小程序与普通网页开发的区别？\r\n​ 小程序的主要开发语言是 JavaScript ，所以通常小程序的开发会被用来同普通的网页开发来做对比。两者有很大的相似性，对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。\r\n\r\n​ 网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。\r\n\r\n​ 网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的。\r\n```\r\n![](https://www.tuziki.com/post-images/1683401709704.png)\r\n\r\n**小程序运行环境：**\r\n运行环境：\r\n+ 在ios中，小程序的JavaScript代码是运行在JavaScriptCore中，是由WKWebView来渲染的\r\n+ 在Android中，小程序的JavaScript代码是通过X5 JSCore来解析，是由腾讯X5内核来渲染的\r\n+ 在开发工具中，小程序的JavaScript代码运行在NWJS中，是ChromeWebView来渲染的\r\n\r\n特点：\r\n+ 微信小程序中不是使用传统的html标签来开发，而是使用WXML标记语言\r\n+  没有window全局变量，但提供了内置的wx.全局方法集\r\n+  安卓版本可以将小程序添加到手机桌面，类似于PWA应用\r\n+  没有超链接，iframe只能在之内的WebView容器内使用\r\n+  事件绑定和条件渲染全部都写在WXML中，这点类似VUE的语法结构\r\n+  数据绑定采用Mustache双大括号语法\r\n+  无法操作DOM，通过setData改变page data来操作数据驱动，这点和react的 setState很像\r\n+  目前还无法直接分享到朋友圈，正在灰度测试\r\n>https://developers.weixin.qq.com/ebook?action=get_post_info&docid=000668c6910b784b00860870a5ac0a\r\n\r\n**小程序从用户点击到销毁经历怎样的过程是怎样的？**\r\n可以用以下的流程图来看：\r\n1、点击打开\r\n2、加载代码包\r\n3、解析app.json渲染全局样式\r\n4、加载文件，解析代码\r\n5、创建View进程\r\n6、通知AppSerice\r\n7、显示触发onReady\r\n8、关闭触发onUnload\r\n![](https://www.tuziki.com/post-images/1683401897144.png)\r\n\r\n**而这一整次的数据渲染是怎样进行的？**\r\n也就是我们页面中的page data()在 setData 发生了什么？\r\n\r\n渲染层 -> Native (点击事件)\r\nNative -> 逻辑层 (点击事件)\r\n逻辑层 -> Native (setData)\r\nNative -> 渲染层 (setData)\r\n\r\n可以看到通信一次是比较麻烦且耗时，虽然 setData 的设计和 React 类似，但是内部却是不同的，React 是异步在下一个时间节点合并 setState 然后进行 state 的处理，属于是异步。而 setData 的修改和 Vue 的机制类似，是对 data 进行同步的更新，但是对于渲染层的改变却是异步的。\r\n\r\n    我们发现小程序的组织结构和 Vue 很像，都是使用 template 语法，这样可以降低开发者使用门槛，\r\n    另一方面却使用类似 React 的 setState 的显示调用更新机制。\r\n    为什么不使用类似 Vue 一样的直接修改 data 的值呢？\r\n    因为小程序的软件架构，视图层是webview线程，逻辑层是jscore线程，并不具备直接通信的通道。\r\n    所以为了视图层和逻辑层的通信，两边都采用了 evaluateJavascript 来和 Native 层通信，导致了小程序必须得通过显示调用的方式来修改 data 的值，这样才能够通知到 Native 层。\r\n    evaluateJavascript 只能传字符串，\r\n    所以我们的 data 中的数据都会进行 JSON.stringify 转义成字符串进行传递。\r\n\r\n**代码包**\r\n分为 开发版、体验版、正式版 三种：\r\n开发版：每个开发者在开发过程中点击“预览”生成的版本，每个小游戏可以有多个开发版，对于每个开发者本地只能有一个开发版；开发版代码包只能通过扫码获得；\r\n体验版：通过在管理后台将特定开发版设置成体验版得到的版本，每个小游戏只能有一个体验版；\r\n正式版：正式发布在线上的版本，每个小游戏只能有一个正式版\r\n\r\n包大小限制：\r\n代码包总大小不能超过 16M，单个分包不能超过 4M。\r\n（最近正在灰度测试16M大包）\r\n\r\n**小程序的运行机制——前台/后台状态**\r\n+ 小程序启动后，界面被展示给用户，此时小程序处于前台状态。\r\n\r\n+ 当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。\r\n\r\n+ 当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。\r\n  \r\n**小程序的运行机制——启动方式**\r\n冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。\r\n\r\n热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。\r\n\r\n**小程序的运行机制——更新机制**\r\n未启动时更新\r\n开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。\r\n\r\n启动时更新\r\n小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。\r\n如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。\r\n![](https://www.tuziki.com/post-images/1683402192668.png)\r\n\r\n**小程序的运行机制——销毁时机**\r\n当小程序进入后台，可以维持一小段时间的运行状态，***如果这段时间内都未进入前台***，小程序会被销毁。\r\n\r\n当小程序***占用系统资源过高***，可能会被系统销毁或被微信客户端主动回收。在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。\r\n\r\n**小程序的登录及实名流程**\r\n登录的多种形式：\r\n+ 拉起微信授权登录\r\n+ 账号密码登录\r\n+ 手机号登录\r\n（登录不可以强制登录，不然不能通过微信审核）\r\n\r\n实名流程三种方式：\r\n+ 银行卡实名\r\n+ 人脸实名\r\n+ 微信支付实名\r\n\r\n**小程序内嵌h5注意事项**\r\n1. 在WebView容器内打开\r\n<WebView src={this.state.targetUrl} /> WebView标签，作为h5的承载容器，条件需要同时满足 https、域名备案、根目录配置文件。\r\n**潜在的问题: **可以用我们的nginx服务器转发链接到对方服务器，就不用配置服务器根目录文件，但是对方的接口可能和页面是不一样的，请求不对，需要转发所有的请求（文件、图片、接口），所以不建议这种方式\r\n![](https://www.tuziki.com/post-images/1683402338203.png)\r\n\r\n2. 小程序跳转H5：\r\n跳转时，先将url存到localstorage里面，再打开<WebView src={this.state.targetUrl} /> webview页面时提取url并加载\r\n潜在的问题：当对方的页面是用vue写的，H5的A页面跳到B页面，B页面进行返回操作不能用$router.push,需要用$router.replace，push会造成返回时在h5页面无限循环跳\r\n\r\n3. 小程序跳转小程序：\r\n使用限制\r\n**需要用户触发跳转**\r\n从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。\r\n每个小程序可跳转的其他小程序数量限制为**不超过 10 个**\r\n从 2.4.0 版本以及指定日期（具体待定）开始，开发者提交新版小程序代码时，如使用了跳转其他小程序功能，**则需要在代码配置中声明将要跳转的小程序名单**，限定不超过 10 个，否则将无法通过审核。\r\n![](https://www.tuziki.com/post-images/1683402442282.png)\r\n\r\n4. H5跳转小程序：\r\n可以调用```wx.miniProgram.navigateTo({ url: '/pages/login/login' })```\r\n前提是页面上要导入jssdk\r\n```<script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.2.js\"></script>```\r\n\r\n>>在某安公司开发小程序是怎样的?\r\n开发工具及开发环境申请——需要用微信开发者工具进行编译开发，可以只开启预览和调试，关闭编辑，可以在vscode里面做编码开发。申请权限走 **McAfee安全策略**申请使用微信开发者工具，然后再申请开通微信扫码登录权限，开通之后，安全部门会让你更新McAfee的安全策略；接口地址可以用ip形式访问，或者用真机测试。注意，生产环境接口和开发工具登录校验以及调起微信登录都需要切换到外网操作，测试环境接口需要切换内网环境操作。\r\n\r\n**开发框架选择：**\r\n选用taro或者uniapp这种编译工具，目前只编译微信和支付宝的话用taro就可以了，uniapp还可以编译为app，用taro开发，语言选用react做开发，门槛低，一套代码，分开编译，先编译微信，调整一些兼容代码之后再编译为支付宝小程序。\r\n>兼容调整的主要内容在与app.json配置文件中关于navigationBar相关设置，且该文件只支持静态配置，不支持动态变量渲染，所以只能在编译完之后手动改造\r\n![](https://www.tuziki.com/post-images/1683402749733.png)\r\n\r\n**开发时的注意事项：**\r\n+ 不能做强制登录，审核不过\r\n+ 内嵌的第三方业务H5需要是备案过的域名、https、并添加配置文件\r\n+ 人脸识别登录可以用南京统一身份认证的技术（一整套前后端），也可以用微信官方提供的技术，微信官方的技术需要额外的申请权限\r\n+ 静态资源尽量本地化，大图可以外链，首次加载时网速问题会导致页面残缺\r\n+ 页面内容（业务名称、链接、图标）可以做Json配置，这样做非常好，以后不需要微信审核，但是用户在网速不好的情况下，服务器瘫痪的情况下，页面一片白，风险较大\r\n+ 页面公告提示可配置话，在后台发版、压测试，用远程json的形式，实时动态开启页面Notice提示\r\n+ 尽量提前预定发布事件，微信审核在工作日较快，一般半天内可以审核玩，周末及工作日晚上审核较慢\r\n+ 小程序发布之后，可以在微信后台开启小程序测评，开启之后，根据小程序的测评功能，可以开启一系列功能，比如 2小时内极速审核、微信人脸身份认证接口、被搜索加权、16M大包体、实时日志\r\n\r\n**发布时的注意事项：**\r\n+ 页面模块较多，工程量大的时候，可以采用小程序的分包开发形式\r\n+ 页面上的数据，尽量多采用本地Storage的形式，与用户的登录态绑定，退出即清空\r\n+ 页面上要做每次打开更新检测及提示，采用微信api那一套\r\n+ 页面除了做微信数据统计也可以做腾讯mta数据统计和百度统计，做事件分析，这样可以较准确的统计，用户的点击次数，或者实名情况\r\n\r\n**微信小程序的开发资源有哪些：——UI组件库**\r\nWeUI ，腾讯微信，原生基础样式，风格简约大方，可以与微信本身风格一致，升级版为KboneUI \r\niViewUI，TalkingData ，比较实用\r\nMinUI ，由蘑菇街，与其他UI库相比，更加注重页面文本模块的细节布局\r\nColorUI ，文晓港团队，库如其名，组件库丰富，年轻化，花里胡哨的好看\r\nVant UI，有赞，为电商购物类小程序提供了很多现成的基础组件\r\nTaroUI ，京东，整体风格简约、清新、统一，适合工具、读书、资讯、教育、商务等类型的小程序\r\nWuxUI，skyvow (GitHub 账号名) ，组件库最为丰富，又很多其他库所没有的组件，如进度环、骨架屏、筛选栏、数字键盘、结果页等实用工具类组件\r\nDemo和详情可见 https://www.ifanr.com/minapp/1196588\r\n\r\n**微信小程序的开发资源有哪些：——开发框架**\r\n![](https://www.tuziki.com/post-images/1683403129975.png)\r\n![](https://www.tuziki.com/post-images/1683403157955.png)\r\n\r\n**微信小程序的开发资源有哪些：——开发资讯**\r\n\r\n每周为你提供高质量的关于小程序、h5等前端领域的文章和项目\r\nhttps://www.ctolib.com/Tnfe-TNFE-Weekly.html\r\n\r\n微信小程序开发资源汇总\r\nhttps://www.ctolib.com/javascript/categories/javascript-wechat-weapp.html\r\n\r\n\r\n",
      "data": {
        "title": "《小程序开发实践与优化》",
        "date": "2023-05-07 02:49:28",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "lesslessxiao-cheng-xu-kai-fa-shi-jian-yu-you-hua-greatergreater"
    },
    {
      "content": "## **具体操作可以看官方文档**\r\nhttps://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html\r\n\r\n## **下面主要总结一些过程中可能遇到的问题:**\r\n1. 域名是https并且备案\r\n2. 公众号JS安全域名里面有登记你的前端域名,https://mp.weixin.qq.com/\r\n3. ip白名单列表里面有登记服务器出口外网IP地址\r\n4. 公众号必须是服务号,订阅号不可以用,非个人主体的\r\n5. 遇到VUE报错 <wx-open-launch-weapp> 未定义,需要新增这个标签,在main.js中添加 Vue.config.ignoredElements.push('wx-open-launch-weapp')  ,如果使用了 Vue.config.ignoredElements=['wx-open-launch-weapp'] 会覆盖所有自定义标签,不可用\r\n6. 微信开发者工具和真机都可以显示出按钮的,chrome浏览器不行\r\n7. 后台接口已经完成签名校验,并返回正确的值,注意前后端使用的appid必须是同一个\r\n8. JSSDK要使用高版本的,https://res2.wx.qq.com/open/js/jweixin-1.6.0.js \r\n9. 确认config中nonceStr（js中驼峰标准大写S）, timestamp与用以签名中的对应noncestr, timestamp一致\r\n10. 最好开启wx.config的debug模式,方便调试\r\n11. jsApiList:['chooseImage', 'previewImage']（必须有，不然安卓不显示）\r\n12. 微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上\r\n13. wx.config中的配置项必填的一定是必填的\r\n14. 不能用js来模拟点击，有局限性\r\n15. 样式无法写在外面中，只能在script标签内内链写或者行内样式\r\n16. 无论是内链还是行内 都不支持rem\r\n17. 不会继承样式\r\n18. 如果开发标签内需要使用图片，不能用本地图片，得用外网可以访问的图片，要不然会不显示\r\n19. path是需要跳转的微信小程序的路径，需要在路径后边添加.html。否则跳转不过去\r\n20. html 页面可以用 <template></template> 标签包裹，Vue 页面要改用 <script type=\"text/wxtag-template\"></script> 包裹\r\n21. 后端的加密方法是 hex_sha1\r\n22. username是需要跳转小程序的原始id，以gh_开头\r\n\r\n```javascript\r\n<template>\r\n    <div class=\"home-wrap\">\r\n        <div class=\"top\">\r\n            目标ID: {{ this.id }} <br /><br />\r\n            目标路径: {{ this.url }}\r\n        </div>\r\n        <div class=\"xxbtn\">\r\n            <wx-open-launch-weapp id=\"launch-btn\" :username=\"id\" :path=\"`${url}.html`\">\r\n                <script type=\"text/wxtag-template\">\r\n                    <style>.openbtn { display: block;width: 280px;height: 42px;line-height: normal;border: none;background-color: #11961c;color: #fff;font-size: 18px;border-radius: 6px;}</style>\r\n                    <button class=\"openbtn\">打开小程序</button>\r\n                </script>\r\n            </wx-open-launch-weapp>\r\n        </div>\r\n    </div>\r\n</template>\r\n  html 页面可以用 <template></template> 标签包裹，Vue 页面要改用 <script type=\"text/wxtag-template\"></script> 包裹\r\n\r\n\r\n<script>\r\nimport {\r\n    isInWechat, isInApp, getUrlParamValue, getToken\r\n} from '@/common/util/env-helper'\r\nimport { getSignData } from '../service/api'\r\n\r\nexport default {\r\n    name: 'Home',\r\n    data() {\r\n        return {\r\n            isInWechat: isInWechat(),\r\n            isInApp: isInApp(),\r\n            code: getUrlParamValue('code'),\r\n            token: getToken(),\r\n            id: '',\r\n            url: ''\r\n        }\r\n    },\r\n    created() {\r\n        const { id, url } = this.$route.query\r\n        this.id = id\r\n        this.url = url\r\n    },\r\n    async mounted() {\r\n        if (this.id && this.url) {\r\n            await this.pageConfig()\r\n        }\r\n    },\r\n    methods: {\r\n        async pageConfig() {\r\n            console.log('this.isInApp :>> ', this.isInApp)\r\n            if (this.isInApp) {\r\n                // const data = await checkUser()\r\n                // if (data) {\r\n                //     this.$router.push('/record')\r\n                // }\r\n            }\r\n            // if (this.isInWechat) {}\r\n            const params = {\r\n                version: '2.0.0',\r\n                type: 'H5',\r\n                // url: 'https://cxxxxxx.com/szswj/stg2/app/feature/reserve/#/'\r\n                url: window.location.href.split('#')[0]\r\n            }\r\n            const res = await getSignData(params)\r\n            console.log('res', res.data)\r\n            const info = res.data\r\n            const configs = {\r\n                debug: true,\r\n                appId: 'wx123456789',\r\n                ...info,\r\n                jsApiList: [\r\n                    'showOptionMenu',\r\n                    'updateAppMessageShareData',\r\n                    'updateTimelineShareData',\r\n                    'chooseImage',\r\n                    'previewImage'\r\n                ],\r\n                openTagList: ['wx-open-launch-weapp'] // 必填，需要使用的JS接口列表\r\n            }\r\n\r\n            console.log('configs---', configs)\r\n            window.wx.config(configs)\r\n\r\n            window.wx.ready(() => {\r\n                console.log('ready')\r\n                // window.wx.updateAppMessageShareData(shareData) // “分享给朋友”及“分享到QQ”\r\n                // window.wx.updateTimelineShareData(shareData) // “分享到朋友圈”及“分享到QQ空间”\r\n            })\r\n            window.wx.error(resp => {\r\n                console.error(`[WechatAgent--] 初始化微信sdk时发生异常: ${JSON.stringify(resp)}`)\r\n            })\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style lang=\"scss\" scoped>\r\n.xxbtn{\r\n    margin: 200px auto 0;\r\n    width:280px;\r\n}\r\n\r\n</style>\r\n```\r\n**类似案例:**\r\nhttps://developers.weixin.qq.com/community/develop/article/doc/0006ac9d35cc38455deb68ee350813\r\nhttps://www.cnblogs.com/Can-daydayup/p/15404964.html#_label1\r\nhttps://blog.csdn.net/Angelheca/article/details/125444337\r\nhttps://blog.csdn.net/qq_32684617/article/details/124901270\r\nhttps://blog.csdn.net/weixin_44265066/article/details/125673122    云函数跳转\r\n",
      "data": {
        "title": "微信中h5页面跳转微信小程序注意事项",
        "date": "2023-05-07 02:12:19",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wei-xin-zhong-h5-ye-mian-tiao-zhuan-wei-xin-xiao-cheng-xu-zhu-yi-shi-xiang"
    },
    {
      "content": "### 1、需要调用比较新的JSSDK\r\n```<script src=\"//res.wx.qq.com/open/js/jweixin-1.6.0.js\"></script>```\r\n\r\n### 2、是否微信环境判断\r\n```javascript\r\nconst isWeChat = () => {\r\n    // window.navigator.userAgent属性包含了浏览器类型、版本、操作系统类型、浏览器引擎类型等信息，这个属性可以用来判断浏览器类型\r\n    const ua = window.navigator.userAgent.toLowerCase()\r\n    // 通过正则表达式匹配ua中是否含有MicroMessenger字符串\r\n    // eslint-disable-next-line\r\n    if (ua.match(/MicroMessenger/i) == 'micromessenger') {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n```\r\n### 3、发送请求拿到后端的校验签名\r\n```javascript\r\nimport axios from 'axios'\r\nimport { isWeChat } from './env-helper'\r\n\r\nif (isWeChat()) {\r\n    // 微信二次分享\r\n    const data = {\r\n        version: '2.0.0',\r\n        type: 'H5',\r\n        url: window.location.href.split('#')[0]\r\n    }\r\n    const shareData = {\r\n        title: '', // 分享标题\r\n        desc: '', // 分享描述\r\n        link: '', // 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致\r\n        imgUrl: '', // 分享图标\r\n        success: function () {\r\n          // 设置成功\r\n        }\r\n    }\r\n    axios({\r\n        headers: {\r\n            'Content-Type': 'application/json'\r\n        },\r\n        method: 'post',\r\n        url: `//${apiBase}/coupon/weixin/getWeixinShareCfg`,\r\n        data: JSON.stringify(data)\r\n    })\r\n        .then((res) => {\r\n            const info = res.data.data\r\n            window.wx.config({\r\n                  debug: true, // 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。\r\n                  appId: '', // 必填，公众号的唯一标识\r\n                  timestamp: , // 必填，生成签名的时间戳\r\n                  nonceStr: '', // 必填，生成签名的随机串\r\n                  signature: '',// 必填，签名\r\n                  ...info,\r\n                  jsApiList: ['updateAppMessageShareData', 'updateTimelineShareData'] // 必填，需要使用的JS接口列表\r\n            })\r\n            window.wx.ready(() => {\r\n                window.wx.updateAppMessageShareData(shareData) // “分享给朋友”及“分享到QQ”\r\n                window.wx.updateTimelineShareData(shareData) // “分享到朋友圈”及“分享到QQ空间”\r\n            })\r\n            window.wx.error((resp) => {\r\n                console.error(`[WechatAgent] 初始化微信sdk时发生异常: ${JSON.stringify(resp)}`)\r\n            })\r\n        })\r\n        .catch((error) => {\r\n            console.error(`[WechatAgent] 调用微信sdk初始化配置接口时发生异常: ${JSON.stringify(error)}`)\r\n      })}\r\n```\r\n这样即为注册微信分享和朋友圈分享成功。\r\n\r\n**如果还是分享不成功或者 微信调用时，提示invalid signature，即签名错误解决办法：**\r\n一、接口配置信息配置，配置这项主要用于你自己服务器检验确定信息来自微信服务器。必须配置，但你可以不使用，你能通过这个配置判断信息是不是微信服务器的返回结果，避免网络安全中有人伪装微信服务器给你返回结果。当然如果你觉得自己的公众号程序达不到让人伪装欺诈的地步，你可以配置了不使用。按照接入接口教程还是比较容易完成的。\r\n![](https://www.tuziki.com/post-images/1683396058261.png)\r\n二、JS接口安全域名配置，微信服务器只响应配置的域名服务器进行JS接口调用，并且避免有人截断伪造信息，还需要利用微信公众号的方法进行签名认证。\r\n![](https://www.tuziki.com/post-images/1683396148069.png)\r\n三、配置好两边的服务器后，也会出现签名无效。\r\n\r\n配置Js安全接口域名，微信服务器可以保证请求是你的服务器发出的，Signature可以保证数据传输途中没有被人截断修改过。\r\n\r\ninvalid signature签名错误。建议按如下顺序检查：\r\n\r\n1.确认签名算法正确，可用http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign 页面工具进行校验。\r\n2.确认config中nonceStr（js中驼峰标准大写S）, timestamp与用以签名中的对应noncestr, timestamp一致。\r\n3.确认url是页面完整的url(请在当前页面alert(location.href.split('#')[0])确认)，包括'http(s)😕/'部分，以及'？'后面的GET参数部分,但不包括'#'hash后面的部分。\r\n4.确认 config 中的 appid 与用来获取 jsapi_ticket 的 appid 一致。\r\n5.确保一定缓存access_token和jsapi_ticket。\r\n**6.确保你获取用来签名的url是动态获取的，动态页面可参见实例代码中php的实现方式。如果是html的静态页面在前端通过ajax将url传到后台签名，前端需要用js获取当前页面除去'#'hash部分的链接（可用location.href.split('#')[0]获取,而且需要encodeURIComponent），因为页面一旦分享，微信客户端会在你的链接末尾加入其它参数，如果不是动态获取当前链接，将导致分享后的页面签名失败。**\r\n\r\n这个过程中最容易出错的是第6步， 如果签名一致，那问题基本出在浏览器访问的url和参与生成签名的url不一致。\r\n第6步中（1）将微信请求的链接提取出来var htmlUrl = location.href.split('#')[0];\r\n            （2）encodeURIComponent(htmlUrl)；传送到后台的URl要经过encodeURIComponent()处理。\r\n```javascript\r\n$(function (){\r\n\tvar htmlUrl = location.href.split('#')[0];\r\n\t$.ajax({type:\"POST\", url:\"${contextPath}RealTimeTicket.do\", data:{\"code\":1, \"htmlUrl\": encodeURIComponent(htmlUrl)}, dataType:\"JSON\",\r\n\t\tsuccess: function(res) {\r\n\t\t       if('success' == res.result){\r\n\t\t\t\twx.config({\r\n\t\t\t\t    debug: true, \r\n\t\t\t\t\tappId: res.appId, // 必填，公众号的唯一标识\r\n\t\t\t\t\ttimestamp: res.timestamp, // 必填，生成签名的时间戳\r\n\t\t\t\t\tnonceStr: res.nonceStr, // 必填，生成签名的随机串\r\n\t\t\t\t\tsignature: res.signature,// 必填，签名\r\n\t\t\t\t\tjsApiList: [\"openLocation\", \"getLocation\"] \r\n\t\t\t\t\t});\r\n\t\t\t\t\t\tconsole.log('successful');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\talert('ticket获取失败!');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n```\r\n（3）Java后台获取URl生成Signature，URL也要经过反encodeURI处理String URL=new java.net.URI(htmlUrl).getPath();这样获取的链接才是微信服务器生成Signature所用的URL。试想一下：你生成Signature用的是你自己获得的URL，微信服务器生成Signature用的是它实际收到请求的URL,两者生成的signature肯定不一样，微信服务器肯定返回你的Signature无效（invalid signature）\r\n \r\n微信 JS 接口签名校验工具\r\nhttps://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign\r\n\r\n分享接口及参数\r\nhttps://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#4\r\n\r\n（部分知识点总结来自https://blog.csdn.net/zhh0310235/article/details/102835292）\r\n\r\n",
      "data": {
        "title": "微信二次分享常见问题",
        "date": "2023-05-07 01:52:41",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wei-xin-er-ci-fen-xiang-chang-jian-wen-ti"
    },
    {
      "content": "一、立项阶段：\r\n关键词——时间与效率 \r\n**制定供应商评分系统**\r\n1.评分包括效率、质量、服务，同时可增加供应商特点、风险点、历史问题记录等信息作为供应商选择参考\r\n2.制定时间节点确定流程与规范（包括项目启动时间、完成时间、阶段性交付时间，以邮件或其他形式确定和公示）\r\n3.制定延期扣分处罚规则（例如交付点延期多少小时记多少分，项目最终定稿时间延误多少天记多少分） \r\n\r\n二、过程阶段：\r\n关键词——服务与沟通\r\n**制定确定供应商的项目负责人流程和扣分规则**\r\n1.扣分规则里，分数可分为供应商分数和具体负责人分数，项目扣分落实到对应供应商和实际负责人\r\n2.制定响应速度超时扣分规则\r\n3.制定主动沟通培训内容（列举常见应主动沟通情景、沟通技巧等、出现典型缺乏主动沟通的情景进行扣分\r\n4..制定联调阶段要求和联调注意事项培训内容以及对供应商进行培训 \r\n\r\n三、交付阶段：\r\n关键词——质量与检测 \r\n**制定阶段性交付和项目定稿邮件规范**\r\n1.制定页面还原度扣分规则（可归类为布局位置偏差、色彩偏差、内容错误等方面） \r\n2.制定代码规范、以及不规范扣分规则\r\n3.制定兼容性测试终端列表以及兼容问题扣分规则 \r\n4.制定性能优化的事项列表（如合并压缩等） \r\n5.制定安全要求（XSS等）和安全问题扣分规则\r\n6.制定用户体验优化事项列表和对应扣分规则\r\n7.制定质检事项培训内容以及对供应商进行培训\r\n8.使用自动化检测工具进行规范、体验、安全、兼容性等问题的检测 \r\n\r\n评价分数可与项目结算价格直接挂钩，并鼓励供应商将评价得分落实到给对应负责人进行奖惩。\r\n总结，就是搞个系统性的评分标准可以直接影响他们的收益。\r\n仅供参考\r\nhttp://tgideas.qq.com/cguide/#J_CP_file\r\nhttp://tgideas.qq.com/cpexp/checkhtml/update.shtml 包括自动化检查工具\r\n\r\n**| 某某某平台的开发 |**\r\n|  |1.完成质量|2.视觉还原|3.是否遵守代码规范|4.兼容性|5.移动端适配|6.性能（图片是否压缩等）|7.交付前是否进行自测|8.是否存在明显问题|9.安全性问题|10.XSS 等 |11.服务态度|12.响应速度|13.是否主动沟通|14.定稿后以邮件形式确定|15.配合联调|16.完成效率|17.合理排期|18.按时交付|19.没有延期|\r\n|:-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|-:|\r\n|张三t|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\r\n|李四a|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\r\n|锋锋c|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\r\n|科科b|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|\r\n",
      "data": {
        "title": "供应商评价标准&&外包管理体系总结",
        "date": "2023-05-07 01:49:47",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-ying-shang-ping-jie-biao-zhun"
    },
    {
      "content": "swiper3~8众多版本中,如果不能找对版本和使用方式,会很难受.\r\n实现移动端轮播图,并且有缩放图片功能的方法很多\r\n## 第一种,需要考虑横屏滑动,使用swiper \r\n功能需要完成横竖屏滑动,图片放大功能,左右点击\r\n在vue2项目中使用需要注意的:\r\n安装时需要 npm install swiper@4  才能指定安装4的版本,\r\n其他拓展api方法可以看 https://v1.github.surmon.me/vue-awesome-swiper/  ,以及 swiper3的api,使用时需要注意哪些是4以上才可以使用的 https://www.swiper.com.cn/api/loop/22.html\r\n(有时候不能缩放是因为html文件上设置了禁止缩放,但是如果是按下面的方法操作应该不用考虑这个问题  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\">)\r\n```javascript\r\n\"swiper\": \"^4.5.1\",\r\n\"vant\": \"^2.10.2\",\r\n\"vue\": \"^2.6.14\",\r\n\"vue-awesome-swiper\": \"^3.1.3\",\r\n```\r\n下面是完整的页面:\r\n其中包含了延时加载和横屏遮罩功能;\r\n以后的这种项目只需要上传好完图片到服务器，即可使用，不用再开发；\r\n填好对应的值，page 服务器文件夹名称，title 图片展名称，num 图片总数， vertical 是否横屏true false ，type 图片格式\r\nhttps://xxxx.com/#/imageshow?page=dashaRiver&title=xxx图片展&num=61&vertical=false&type=png\r\n```javascript\r\n<template>\r\n    <div>\r\n        <swiper\r\n            class=\"swiper-container\"\r\n            :options=\"swiperOption\"\r\n            ref=\"imgOverview\"\r\n            style=\"height: 100%;\"\r\n        >\r\n            <swiper-slide class=\"swiper-slide\" v-for=\"img in list\" :key=\"img\">\r\n                <div class=\"swiper-zoom-container\">\r\n                    <img :data-src=\"img\" alt=\"\" class=\"swiper-lazy\" />\r\n                    <div class=\"swiper-lazy-preloader\"></div>\r\n                </div>\r\n            </swiper-slide>\r\n            <div\r\n                id=\"swiper-pagination\"\r\n                :class=\"['swiper-pagination', `${this.pageVertical && 'vv'}`]\"\r\n                slot=\"pagination\"\r\n            ></div>\r\n            <!-- 分页 -->\r\n            <div class=\"btnL swiper-button-prev\" slot=\"button-prev\" v-if=\"!pageVertical\"></div>\r\n            <div class=\"btnR swiper-button-next\" slot=\"button-next\" v-if=\"!pageVertical\"></div>\r\n            <div class=\"btnT swiper-button-prev\" slot=\"button-prev\" v-if=\"pageVertical\"></div>\r\n            <div class=\"btnB swiper-button-next\" slot=\"button-next\" v-if=\"pageVertical\"></div>\r\n        </swiper>\r\n        <van-overlay :show=\"showOverlay\" @click=\"showOverlay = false\">\r\n            <div class=\"wrapper\" @click.stop>\r\n                请横屏观看\r\n            </div>\r\n        </van-overlay>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport 'swiper/dist/css/swiper.min.css'\r\nimport { swiper, swiperSlide } from 'vue-awesome-swiper'\r\n\r\nexport default {\r\n    name: 'showPic',\r\n    data() {\r\n        return {\r\n            current: 0,\r\n            list: [],\r\n            showOverlay: false,\r\n            pageKey: '',\r\n            pageTitle: '',\r\n            pageNum: '',\r\n            pageType: '',\r\n            pageVertical: true,\r\n            swiperOption: {\r\n                direction: this.$route.query.vertical === 'false' ? 'horizontal' : 'vertical',\r\n                width: window.innerWidth,\r\n                height: window.innerHeight,\r\n                // zoom: true,\r\n                loop: true,\r\n                zoom: {\r\n                    minRatio: 1,\r\n                    maxRatio: 10\r\n                },\r\n                lazy: true,\r\n                initialSlide: 0,\r\n                navigation: {\r\n                    nextEl: '.swiper-button-next',\r\n                    prevEl: '.swiper-button-prev'\r\n                },\r\n                pagination: {\r\n                    el: '#swiper-pagination',\r\n                    type: 'fraction'\r\n                }\r\n            }\r\n        }\r\n    },\r\n    components: {\r\n        swiper,\r\n        swiperSlide\r\n    },\r\n    created() {\r\n        const {\r\n            page, title, num, vertical, type\r\n        } = this.$route.query\r\n        if (page) {\r\n            this.pageKey = page\r\n            this.pageTitle = title\r\n            this.pageNum = num\r\n            this.pageVertical = vertical !== 'false'\r\n            this.pageType = type\r\n            document.title = title\r\n            this.showOverlay = vertical === 'true'\r\n            setTimeout(() => {\r\n                this.showOverlay = false\r\n            }, 2200)\r\n            this.cutImg()\r\n        }\r\n    },\r\n    mounted() {},\r\n    methods: {\r\n        cutImg() {\r\n            const list = []\r\n            for (let index = 1; index <= this.pageNum; index++) {\r\n                list.push(\r\n                    `https://xxxx.com/prod/lib/${this.pageKey}/${index}.${this.pageType}`\r\n                )\r\n            }\r\n            this.list = list\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.van-overlay {\r\n    z-index: 10000;\r\n}\r\n.wrapper {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-size: 30px;\r\n    color:#fff;\r\n}\r\n.btnL,\r\n.btnR,\r\n.btnT,\r\n.btnB {\r\n    position: absolute;\r\n    width: 40px;\r\n    height: 40px;\r\n    margin-top: 0;\r\n}\r\n.btnL {\r\n    top: 50%;\r\n    left: 0;\r\n    transform: translate(0, -50%);\r\n    background: url('../asset/img/arrow-left.png') center no-repeat;\r\n    background-size: 30px;\r\n}\r\n.btnR {\r\n    top: 50%;\r\n    right: 0;\r\n    transform: translate(0, -50%);\r\n    background: url('../asset/img/arrow-right.png') center no-repeat;\r\n    background-size: 30px;\r\n}\r\n.btnT {\r\n    top: 0;\r\n    left: 50%;\r\n    transform: translate(-50%, 0);\r\n    background: url('../asset/img/arrow-up.png') center no-repeat;\r\n    background-size: 30px;\r\n}\r\n.btnB {\r\n    top: auto;\r\n    bottom: 0;\r\n    left: 50%;\r\n    transform: translate(-50%, 0);\r\n    background: url('../asset/img/arrow-down.png') center no-repeat;\r\n    background-size: 30px;\r\n}\r\n// width: 7.5rem;\r\n.swiper-container {\r\n    width: 100%;\r\n    height: 100%;\r\n    .swiper-slide {\r\n        width: 100%;\r\n        height: 100vh;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n    }\r\n    .swiper-slide img {\r\n        max-width: 100%;\r\n        max-height: 100%;\r\n    }\r\n    .swiper-pagination {\r\n        z-index: 10000;\r\n        position: fixed;\r\n        bottom: 8px;\r\n        left: 50%;\r\n        transform: translate(-50%, 0);\r\n        width: 50px;\r\n        height: 20px;\r\n        text-align: center;\r\n        font-size: 12px;\r\n        &.vv {\r\n            top: 50%;\r\n            left: -28px;\r\n            bottom: 0;\r\n            transform: rotateZ(90deg) translate(0, -50%);\r\n        }\r\n    }\r\n    .swiper-button-prev,\r\n    .swiper-button-next {\r\n        position: fixed;\r\n        outline: none;\r\n        &:active {\r\n            border: none;\r\n        }\r\n        &:focus-visible {\r\n            border: none;\r\n        }\r\n    }\r\n}\r\n</style>\r\n```\r\n## 第二种,不需要考虑横屏滑动,且全屏预览,使用 vant的 ImagePreview组件\r\n图片放大预览，支持函数调用和组件调用两种方式,用vue的vant组件库中的 ImagePreview 组件即可 , https://youzan.github.io/vant/v2/#/zh-CN/image-preview\r\n1. 函数调用\r\n```javascript\r\nimport { ImagePreview } from 'vant';\r\nImagePreview({\r\n  images: [\r\n    'https://img01.yzcdn.cn/vant/apple-1.jpg',\r\n    'https://img01.yzcdn.cn/vant/apple-2.jpg',\r\n  ],\r\n    startPosition: 1,    // 初始位置\r\n    showIndex: false,    // 是否显示页码\r\n    closeable: true,      // 是否显示关闭图标\r\n});需要注意的是,常规调用预览模式,手指点击一下,整个预览状态就会消失,需要开启异步调用方式来阻止,开启异步之后,除非手动关闭,不然会一直存在\r\nconst instance = ImagePreview({\r\n       images: this.list,\r\n       asyncClose: true\r\n})\r\n\r\nsetTimeout(() => {\r\n  instance.close();    // \r\n}, 2000);2.组件调用\r\n<van-image-preview v-model=\"show\" :images=\"images\" @change=\"onChange\">\r\n  <template v-slot:index>第{{ index }}页</template>\r\n</van-image-preview>\r\nexport default {\r\n  data() {\r\n    return {\r\n      show: false,\r\n      index: 0,\r\n      images: [\r\n        'https://img01.yzcdn.cn/vant/apple-1.jpg',\r\n        'https://img01.yzcdn.cn/vant/apple-2.jpg',\r\n      ],\r\n    };\r\n  },\r\n  methods: {\r\n    onChange(index) {\r\n      this.index = index;\r\n    },\r\n  },\r\n};\r\n```\r\n## 第三种,最基础的左右滑屏\r\n即可以用vant 的 Swipe 轮播\r\n也可以用 swiper https://www.swiper.com.cn/api/loop/22.html\r\n项目中已经有了vant,就可以直接用了,毕竟swiper很重",
      "data": {
        "title": "swiper再度踩坑指南",
        "date": "2023-05-07 01:29:43",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "swiper-zai-du-cai-keng-zhi-nan"
    },
    {
      "content": "MacOS 安装：\r\nhttps://www.jianshu.com/p/dfb10517d409/\r\n\r\nwindows安装：\r\nhttps://www.runoob.com/mongodb/mongodb-window-install.html\r\n",
      "data": {
        "title": "mongodb安装",
        "date": "2022-06-20 18:33:36",
        "tags": [
          "mongodb"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mongodb-an-zhuang"
    },
    {
      "content": "## VueX（Vue状态管理模式)\r\n\r\n### Vuex 的核心成员列表：\r\n- state 存放状态\r\n- mutations state成员操作\r\n- getters 加工state成员给外界\r\n- actions 异步操作\r\n- modules 模块化状态管理\r\n\r\n正常情况下，我们需要在state里面定义需要操作的对象，并赋值，再调取 getter、和 mutations的setter方法来操作数据，定义比较繁琐\r\n```javascript\r\nimport Vue from 'vue'\r\nimport Vuex from 'vuex'\r\n\r\nVue.use(Vuex)\r\n\r\nconst store = new Vuex.Store({\r\n\tstate: {\r\n\t\taddAppealForm: {\r\n\t\t\tenterpriseAppealNotice: false,\r\n\t\t\tshowPicker: false,\r\n\t\t\tappealType: ''\r\n\t\t},\r\n\t\tsigninForm: {\r\n\t\t\tenterpriseName: '',\r\n\t\t\tuserName: '',\r\n\t\t\tloginPassword: '',\r\n\t\t\tcontactName: ''\r\n\t\t}\r\n\t},\r\n\tgetters: {\r\n\t\tgetAddAppeal(state) {\r\n\t\t\treturn state.addAppealForm\r\n\t\t},\r\n\t\tgetSigninForm(state) {\r\n\t\t\treturn state.signinForm\r\n\t\t}\r\n\t},\r\n\tmutations: {\r\n\t\tsetAddAppeal(state, params) {\r\n\t\t\tstate.addAppealForm = params\r\n\t\t},\r\n\t\tsetSigninForm(state, params) {\r\n\t\t\tstate.signinForm = params\r\n\t\t}\r\n\t}\r\n})\r\n\r\nexport default store\r\n\r\n```\r\n实际业务中写如此多的构建语法会比较繁琐，将模块与vuex所需操作的数据进行剥离，做到类似localStorage的键值对方式存取会更加的方便，这里要用到webpack的api，require.context函数，获取一个特定的上下文，实现自动化导入模块，使得不需要每次显式的调用import导入模块\r\n```javascript\r\n// ./modules/index.js\r\nconst files = require.context('.', false, /\\.js$/)\r\nconst modules = {}\r\n\r\nfiles.keys().forEach((key) => {\r\n\tif (key === './index.js') return\r\n\tmodules[key.replace(/(\\.\\/|\\.js)/g, '')] = files(key).default\r\n})\r\n\r\nexport default modules\r\n\r\n```\r\n```javascript\r\n// index.js\r\nimport Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nimport modules from './modules'\r\n\r\nVue.use(Vuex)\r\n\r\nconst store = new Vuex.Store({\r\n\tmodules\r\n})\r\n\r\nexport default store\r\n\r\n```\r\n从而，在实际的业务需求vuex定义的模块中，动态键值对的设计则是通过Object.keys() 调用``Vue.delete(state, key)``  和  ``Vue.set(state, key, data[key])`` 来实现\r\n```javascript\r\n// process.js\r\n\r\nimport Vue from 'vue'\r\n\r\nexport default {\r\n\tstate: null,\r\n\tmutations: {\r\n\t\tupdateProcessInfo(state, data) {\r\n\t\t\tif (data === null) {\r\n\t\t\t\tObject.keys(state).forEach((key) => {\r\n\t\t\t\t\tVue.delete(state, key)\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tObject.keys(data).forEach((key) => {\r\n\t\t\t\t\tVue.set(state, key, data[key])\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tactions: {}\r\n}\r\n\r\n```\r\n页面调用：\r\n```javascript\r\n// 存入\r\nthis.$store.commit('updateProcessInfo', {processDetail: data})\r\n\r\n// 读取\r\nthis.$store.state.process.processDetail\r\n```\r\n![](https://www.tuziki.com/post-images/1607692443097.png)\r\n\r\n\r\n",
      "data": {
        "title": "vuex中store运用require.context改造为便捷的管理状态器",
        "date": "2020-12-11 11:21:45",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vuex-zhong-store-yun-yong-requirecontext-gai-zao-wei-bian-jie-de-guan-li-zhuang-tai-qi"
    },
    {
      "content": "## VUE版本：\r\n\r\n### 安装:\r\n``` html\r\nnpm install qrcode\r\n\r\nimport QRCode from 'qrcode'\r\n```\r\n\r\n### DOM:\r\n``` html\r\n<canvas id=\"canvas\"></canvas>\r\n```\r\n### 页面调用\r\n``` javascript\r\nthis.useqrcode('http://www.baidu.com')\r\n\r\nuseqrcode(url) {\r\n    const canvas = document.getElementById('canvas')\r\n    QRCode.toCanvas(\r\n        canvas,\r\n        url,\r\n        {\r\n            scale: 5.0,\r\n            height: 180,\r\n            wight: 180\r\n        },\r\n        error => {\r\n            if (error) console.error(error)\r\n            console.log('success!')\r\n        }\r\n    )\r\n}\r\n\r\n```\r\n\r\n<!-- more -->\r\n## React版本：\r\n### 安装:\r\n``` html\r\nnpm install qrcode\r\n\r\nimport QRCode from 'qrcode.react'\r\n```\r\n### DOM:\r\n``` javascript\r\n{this.renderCanvas(url)}\r\n```\r\n### 渲染:\r\n``` javascript\r\nrenderCanvas = url => {\r\n    return (\r\n        <div style={{ width: '200px'}}>\r\n            <p style={{ wordBreak: 'break-all' }}>{url}</p>\r\n            <QRCode\r\n                value={url} //value参数为生成二维码的链接\r\n                size={200} //二维码的宽高尺寸\r\n                fgColor=\"#000000\" //二维码的颜色\r\n            />\r\n        </div>\r\n    )\r\n}\r\n```",
      "data": {
        "title": "vue与react生成前端二维码的QRcode组件使用",
        "date": "2020-12-10 15:14:04",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "## VUE版本：\r\n\r\n### 安装:\r\n``` html\r\nnpm install qrcode\r\n\r\nimport QRCode from 'qrcode'\r\n```\r\n\r\n### DOM:\r\n``` html\r\n<canvas id=\"canvas\"></canvas>\r\n```\r\n### 页面调用\r\n``` javascript\r\nthis.useqrcode('http://www.baidu.com')\r\n\r\nuseqrcode(url) {\r\n    const canvas = document.getElementById('canvas')\r\n    QRCode.toCanvas(\r\n        canvas,\r\n        url,\r\n        {\r\n            scale: 5.0,\r\n            height: 180,\r\n            wight: 180\r\n        },\r\n        error => {\r\n            if (error) console.error(error)\r\n            console.log('success!')\r\n        }\r\n    )\r\n}\r\n\r\n```\r",
      "fileName": "vue-yu-react-sheng-cheng-qian-duan-er-wei-ma-de-qrcode-zu-jian-shi-yong"
    },
    {
      "content": "``watch``: 监视,能够监听到数据的变化,只要数据变化的时候,都会自定执行对应的方法,其中可以检测的数据来源分为三部分 data , computed , props\r\n### 侦听属性watch：\r\n>\r\n+ 不支持缓存，数据变，直接会触发相应的操作\r\n+ watch支持异步\r\n+ 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值\r\n+ 当一个属性发生变化时，需要执行对应的操作；一对多\r\n+ 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：\r\n>\r\n\r\n<!-- more -->\r\n\r\n``computed``:  计算属性,存在一个计算缓存的特性,每一次计算之后,只要里面的逻辑不发生变化,每一次重复调用,都会使用上一次执行的结果,能够节省计算的时间\r\n当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch,通常更好的是使用 computed 属性而不是命令式的 watch 回调\r\n\r\n### 计算属性computed：\r\n> \r\n- 支持缓存，只有依赖数据发生改变，才会重新进行计算\r\n- 不支持异步，当computed内有异步操作时无效，无法监听数据的变化\r\n- computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\r\n如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed\r\n如果computed 属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\r\n\r\nimmediate：组件加载立即触发回调函数执行\r\n``` javascript\r\nwatch: {\r\n  firstName: {\r\n    handler(newName, oldName) {\r\n      this.fullName = newName + ' ' + this.lastName;\r\n    },\r\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\r\n    immediate: true\r\n  }\r\n}\r\n```\r\ndeep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\r\n```javascript\r\nwatch: {\r\n  obj: {\r\n    handler(newName, oldName) {\r\n      console.log('obj.a changed');\r\n    },\r\n    immediate: true,\r\n    deep: true\r\n  }\r\n}\r\n```\r\n优化：我们可以使用字符串的形式监听\r\n```javascript\r\nwatch: {\r\n  'obj.a': {\r\n    handler(newName, oldName) {\r\n      console.log('obj.a changed');\r\n    },\r\n    immediate: true,\r\n    // deep: true\r\n  }\r\n}\r\n```\r\n这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "VUE中watch 和 computed的区别详解",
        "date": "2020-12-09 16:55:45",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "``watch``: 监视,能够监听到数据的变化,只要数据变化的时候,都会自定执行对应的方法,其中可以检测的数据来源分为三部分 data , computed , props\r\n### 侦听属性watch：\r\n>\r\n+ 不支持缓存，数据变，直接会触发相应的操作\r\n+ watch支持异步\r\n+ 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值\r\n+ 当一个属性发生变化时，需要执行对应的操作；一对多\r\n+ 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：\r\n>\r",
      "fileName": "vue-zhong-watch-he-computed-de-qu-bie-xiang-jie"
    },
    {
      "content": "给定一个二维数组转换为树形数据结构。\r\n二维数组如下：\r\n```javascript\r\nconst array = [\r\n    [\"a\", \"aa\", \"aaa\", \"aaaa\"],\r\n    [\"b\", \"bb\", \"bbb\"],\r\n    [\"a\", \"ab\", \"aba\"],\r\n    [\"a\", \"aa\", \"aab\"]\r\n] \r\n```\r\n目标树形结构如下：\r\n```javascript\r\nconst json = [\r\n    {\r\n        \"name\" : \"a\",\r\n        \"child\" : [\r\n            {\r\n                \"name\" : \"aa\",\r\n                \"child\" : [\r\n                    {\r\n                        \"name\" : \"aaa\",\r\n                        \"child\" : [\r\n                            {\r\n                                \"name\" : \"aaaa\",\r\n                                \"child\" : []\r\n                            }\r\n                        ]\r\n                    },\r\n                    {\r\n                        \"name\" : \"aab\",\r\n                        \"child\" : []\r\n                    }\r\n                ]\r\n\r\n            },\r\n            {\r\n                \"name\" : \"ab\",\r\n                \"child\" : [\r\n                    {\r\n                        \"name\": \"aba\",\r\n                        \"child\" : []\r\n                    }\r\n                ]\r\n\r\n            }\r\n        ]\r\n    },\r\n    {\r\n        \"name\": \"b\",\r\n        \"child\" : [\r\n            {\r\n                \"name\" : \"bb\",\r\n                \"child\" : [\r\n                    {\r\n                        \"name\" : \"bbb\",\r\n                        \"child\" : []\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    }\r\n\r\n]\r\n```\r\n**某大佬给出的方法及思路：**\r\n1. 首先你要把一个一维数组转换为一个简单的树/列表，就是循环处理好数组中的每个元素，构造出\r\n   `` { name: 'a', children: [] }`` 结构\r\n2. 然后针对这个二维数组可以构造出 4 个树/列表\r\n3. 观察这 4 个中间结果，找到合并的规则（字母开头要一致，公共父节点值）\r\n4. 编写一个合并两个树/列表的函数，应用第三步整理的规则\r\n\r\n**我的思路：**\r\n1、合并二维数组为一维数组\r\n2、数组去重\r\n3、对这个一维数组进行改造，对每一项标注出它的父级parentId，单字母的parentId为0，具体实现方法为，将每一项去掉尾字母，在新数组里遍历查找与之匹配的那一项，获取其下标 +1，即为该父级parentId\r\n4、对新数据进行遍历，查找每一项的子集数组，如果存在，则给这一项添加children属性，并赋值，否则返回第一层\r\n```javascript\r\nconst array = [\r\n    [\"a\", \"aa\", \"aaa\", \"aaaa\"],\r\n    [\"b\", \"bb\", \"bbb\"],\r\n    [\"a\", \"ab\", \"aba\"],\r\n    [\"a\", \"aa\", \"aab\"]\r\n] \r\nconst arr = []\r\narray.forEach((item) => {\r\n    item.forEach((i) => {\r\n        arr.push(i)\r\n    })\r\n})\r\nconst brr = Array.from(new Set(arr))\r\nconst tree = []\r\n// [\"a\", \"aa\", \"aaa\", \"aaaa\", \"b\", \"bb\", \"bbb\", \"ab\", \"aba\", \"aab\"]\r\nbrr.forEach((j, index) => {\r\n    tree.push({\r\n        id: index + 1,\r\n        parentId: checkId(j),\r\n        name: j\r\n    })\r\n})\r\nfunction checkId(j) {\r\n    const aaa = brr.findIndex(k => j.slice(0, j.length - 1) === k)\r\n    console.log('--', j, aaa + 1)\r\n    return aaa + 1\r\n}\r\nconsole.log(tree)\r\n// 0: {id: 1, parentId: 0, name: \"a\"}\r\n// 1: {id: 2, parentId: 1, name: \"aa\"}\r\n// 2: {id: 3, parentId: 2, name: \"aaa\"}\r\n// 3: {id: 4, parentId: 3, name: \"aaaa\"}\r\n// 4: {id: 5, parentId: 0, name: \"b\"}\r\n// 5: {id: 6, parentId: 5, name: \"bb\"}\r\n// 6: {id: 7, parentId: 6, name: \"bbb\"}\r\n// 7: {id: 8, parentId: 1, name: \"ab\"}\r\n// 8: {id: 9, parentId: 8, name: \"aba\"}\r\n// 9: {id: 10, parentId: 2, name: \"aab\"}\r\nconst cloneData = tree.slice()\r\nconst last = cloneData.filter((father) => {\r\n    const branchArr = cloneData.filter(child => fat her.id === child.parentId) // 返回每一项的子级数组\r\n    // branchArr.length > 0 ? father.children = branchArr : '' // 给父级添加一个children属性，并赋值\r\n    if (branchArr.length > 0) {\t\r\n        father.children = branchArr\t//如果存在子级，则给父级添加一个children属性，并赋值\r\n    }\r\n    return father.parentId === 0 // 返回第一层\r\n})\r\nconsole.log(last) // 树形数据\r\n```\r\n",
      "data": {
        "title": "【算法】二维数组转树形数据结构",
        "date": "2020-10-16 14:25:19",
        "tags": [
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "suan-fa-er-wei-shu-zu-zhuan-shu-xing-shu-ju-jie-gou"
    },
    {
      "content": "问题：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\r\n> 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\r\n```javascript\r\nvar reverse = function(x) {\r\n    const str = '' + x;\r\n    let arr = []\r\n    let operator = ''\r\n    if (str.startsWith('-') || str.startsWith('+')) {\r\n        arr = str.slice(1, str.length).split('');\r\n        operator = str[0]\r\n    } else {\r\n        arr = String(x).split('');\r\n    }\r\n\r\n    const result = Number(operator + arr.reverse().join(''));\r\n    \r\n    if (result < (-2) ** 31 || result > 2 ** 31 -1) {\r\n        return 0;\r\n    }\r\n    return result\r\n};\r\n```\r\n示例 1:\r\n输入: 123    输出: 321\r\n\r\n示例 2:\r\n输入: -123   输出: -321\r\n\r\n示例 3:\r\n输入: 120   输出: 21\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "【算法】整数反转",
        "date": "2020-10-16 14:17:22",
        "tags": [
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zheng-shu-fan-zhuan"
    },
    {
      "content": "一、整体页面划分及架构图\r\n![](https://www.tuziki.com/post-images/1589822830450.png)\r\n\r\n前言，本项目已将【项目】与【团队】数据合并称为【归档】\r\n\r\n1、左边栏是数据源；\r\n        这里展示与当前用户所有相关联的数据，点击操作勾选多个，则可以叠加显示多个【归档】的数据在中间区域显示。\r\n        上部分为数据源操作，下部分为当前已选中的数据。\r\n\r\n2、顶部是日期切换、视图切换、功能操作，用户中心；\r\n**日期切换**：可以操作当前已选中【归档】的时间维度，【我的工作】是月视图，日期切换为月份切换；【项目归档】为月视图，日期切换为月份切换；【团队归档】是周视图，时间切换则为周切换\r\n**视图切换**：分为【我的工作】、【项目归档】、【团队归档】。``我的工作`` 展示个人**每个月**的录入数据；``项目归档``展示左侧栏已勾选的所有项目在**每个月**的录入数据；``团队归档``则是展示左侧已勾选的所有项目在**每一周**里所有项目**参与人**的录入数据\r\n**功能操作**：包括创建归档（团队归档、项目归档）、周报展示、月报展示、年报展示\r\n**用户中心**：包括用户相关信息的修改登记，头像、昵称、电话、邮箱\r\n\r\n3、中间区域是数据展示，分为月视图、周视图。其中周视图为该团队，人员列表和他在一周的项目录入组合成的列表。\r\n",
      "data": {
        "title": "【工作日历】开发架构图",
        "date": "2020-05-19 01:26:24",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-zuo-ri-li-kai-fa-jia-gou-tu"
    },
    {
      "content": "1、CSP: Content-Security-Policy详解\r\nhttps://www.jianshu.com/p/74ea9f0860d2\r\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy\r\n\r\n2、XSS\r\n3、CSRF\r\n",
      "data": {
        "title": "web安全记事",
        "date": "2020-05-16 16:34:06",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "web-an-quan-ji-shi"
    },
    {
      "content": "一般情况下在nginx.conf文件里做以下配置改动就好\r\n```nginx\r\nhttp {\r\n    ##\r\n    # `gzip` Settings\r\n\r\n    gzip on;\r\n    gzip_disable \"msie6\";\r\n\r\n    gzip_vary on;\r\n    gzip_proxied any;\r\n    gzip_comp_level 6;\r\n    gzip_buffers 16 8k;\r\n    gzip_http_version 1.1;\r\n    gzip_min_length 256;\r\n    gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;\r\n}\r\n```",
      "data": {
        "title": "nginx开启gzip压缩",
        "date": "2020-05-14 19:53:36",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "nginx-kai-qi-gzip-ya-suo"
    },
    {
      "content": "尽可能的用到所见所闻的技术手段。\r\nDemo：<a href=\"https://www.souxy.com/demo/shizijia/\" target=\"_blank\">www.souxy.com/demo/shizijia</a>\r\n\r\n1、单纯的dom元素加css，还可以细分为定位法、浮动法\r\n2、css background filter 方法\r\n3、svg方法\r\n4、canvas方法\r\n5、vml方法\r\n6、伪类的content方法、伪类的拼接方法\r\n7、\"+\"字符方法\r\n8、iconfont方法\r\n9、base64方法\r\n10、background-clip方法\r\n",
      "data": {
        "title": "前端有多少种方式实现一个十字架？",
        "date": "2020-05-13 02:31:12",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "qian-duan-you-duo-shao-chong-fang-shi-shi-xian-yi-ge-shi-zi-jia"
    },
    {
      "content": "首先，你需要一个灵关一闪的idea。\r\n",
      "data": {
        "title": "怎样将一个idea从构思到实现",
        "date": "2020-05-13 02:29:41",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zen-yang-jiang-yi-ge-idea-cong-gou-si-dao-shi-xian"
    },
    {
      "content": "### 方法一：直接定义并且初始化，这种遇到数量少的情况可以用\r\n``var _TheArray = [[\"0-1\",\"0-2\"],[\"1-1\",\"1-2\"],[\"2-1\",\"2-2\"]]``\r\n\r\n### 方法二：未知长度的二维数组\r\n```javascript\r\nvar tArray = new Array();  //先声明一维\r\nfor(var k=0;k<i;k++){    //一维长度为i,i为变量，可以根据实际情况改变\r\n \r\ntArray[k]=new Array();  //声明二维，每一个一维数组里面的一个元素都是一个数组；\r\n \r\nfor(var j=0;j<p;j++){   //一维数组里面每个元素数组可以包含的数量p，p也是一个变量；\r\n \r\ntArray[k][j]=\"\";    //这里将变量初始化，我这边统一初始化为空，后面在用所需的值覆盖里面的值\r\n }\r\n}\r\n给定义的数组传入所需的值\r\ntArray[6][1]=5；//这样就可以将5的值传入到数组中，覆盖初始化的空\r\n```\r\n### 方法三：在这之前，以上两者方法都有问题，方法二，每次定义都初始化了，虽然后面可以动态修改，但是还是不方法\r\n\r\n所以我尝试了一种动态传入值到数组的方法\r\n\r\nps:一些在实践过程中遇到的数组有趣的现象\r\n\r\n本来以为二维数组可以像下面这样直接传入值\r\n```javascript\r\nfor(var a=0;a<i;a++){\r\n    tArray[a]=(matArray[a],addArray[a]); //matArray[a]和addArray[a]是两个数组，这两个数组直接传入tArray[a]中\r\n};\r\n```\r\n结果是tArray[a]中收到的是后面一个数组的值，matArray[a]的内容被忽略的，如果换一个位置，matArray[a]在后面，则传入的是addArray[a]的值。\r\n\r\n思考：简单的例子：\r\n代码如下:\r\n```javascript\r\nvar a=[1,2];\r\nvar b=[];\r\nb[0]=a;//把数组a作为b数组的元素传入b数组中\r\nalert(b[0][1]);  //2\r\n```\r\n上面是最简单的二维数组，\r\n上面例子换种写法：\r\n代码如下:\r\n```javascript\r\nvar b=[];\r\nb[0]=[1,2];//把数组[1,2]作为b数组的元素传入b数组中\r\nalert(b[0][1]);  //2\r\n```\r\n\r\n可以看出上面的b[0]=[1,2]是可以用的\r\n代码如下:\r\n\r\n```javascript\r\nfor(var a=0;a<i;a++){\r\n    tArray[a]=[ matArray[a],addArray[a] ];  //上面例子中的（）修改为[] 就可以成功的组成一个二维数组了\r\n};\r\n总结：方法三：\r\n代码如下:\r\n```javascript\r\nfor(var a=0;a<i;a++){\r\n    tArray[a]=[ aArray[a],bArray[a],cArray[a]]; 还可以增加dArray[a],eArray[a]\r\n};\r\n```\r\n这种情况适用于已知几个数组，把他们组合成一个二维数组情况\r\n\r\nJS 创建多维数组\r\n```javascript\r\n  var allarray=new Array();\r\n  var res=\"\";\r\n  function loaddata()\r\n  {\r\n   for(var i=0;i<3;i++)\r\n {\r\n var starth=i*200;\r\n var strarw=i*200;\r\n var endh=(i+1)*200;\r\n var endw=(i+1)*200;\r\n allarray[i]=new Array();\r\n allarray[i][0]=new Array();\r\n allarray[i][1]=new Array();\r\n allarray[i][0][0]=starth;\r\n allarray[i][0][1]=strarw;\r\n  allarray[i][1][0]=endh;\r\n allarray[i][1][1]=endw;\r\n }\r\n  for(var i=0;i<allarray.length;i++)\r\n  {\r\n    var sh=allarray[i][0][0];\r\n    var sw=allarray[i][0][1]\r\n     var eh=allarray[i][1][0];\r\n    var ew=allarray[i][1][1]\r\n    res+=\"第\"+i+\"个坐标的开始坐标是：\"+sh+\",\"+sw+\"结束坐标是：\"+eh+\",\"+ew+\"<br/>\";\r\n  }\r\n  document.getElementById(\"dv\").innerHTML=res;\r\n  }\r\n```",
      "data": {
        "title": "JavaScript -- 定义二维数组",
        "date": "2020-05-07 00:22:55",
        "tags": [
          "Array"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "javascript-ding-yi-er-wei-shu-zu"
    },
    {
      "content": "### 【Low Code】\r\n\r\n**大厂低代码：**\r\n*  百度——https://aisuda.bce.baidu.com/amis/zh-CN/docs/index ，amis 是一个低代码前端框架，它使用 JSON 配置来生成页面，可以减少页面开发工作量，极大提升效率。\r\n*  网易——数帆https://sf.163.com/，金融低代码平台\r\n*  阿里——LowCodeEngine，https://lowcode-engine.cn/index，功能强大，物料齐全\r\n*  阿里——宜搭https://www.aliwork.com/，表单流程数据可视化，模板多，功能丰富\r\n*  腾讯——微搭https://weda.cloud.tencent.com/index/，颗粒度很细，构建复杂的自动化业务流程，轻松搭建微信小程序和企业生产管理系统\r\n\r\n**低代码库：**\r\nSpreadJS ——https://www.grapecity.com.cn/developer/spreadjs，在线Excel\r\nLuckysheet JS ——https://mengshukeji.gitee.io/LuckysheetDocs/zh，在线Excel\r\n\r\n**H5页面可视化：**\r\nH5DS——https://www.h5ds.com/\r\n易企秀——http://www.eqxiu.com/h5\r\n稿定设计——https://www.gaoding.com/\r\n兔展——https://www.rabbitpre.com/\r\n阿里——云凤蝶https://formilyjs.org/\r\n京东——积木、乐高、羚珑、Quark\r\n\r\n### 【Old Idea】\r\n* 2011年 -- 基于地理位置的LBS商户美食推荐系统\r\n* 2012年 -- 第四方物流与供应链系统（类似现在的滴滴货车和货嘀运力调度中心http://data.tf56.com/huodi.html?city=1）\r\n* 2012年 —- 知识共享系统\r\n\r\n\r\n### 【project】数据可视化配置平台\r\n基于react + dva + redux的可视化配置数据平台的前端工作流程设计方案（不断完善中）\r\n\r\n解决需求：\r\n\r\n+ 解决管理后台动态可配置\r\n\r\n+ 解决数据图表动态添加修改可配置\r\n\r\n+ 解决数据源与数据图表可配置\r\n\r\n> 落地产品：类似阿里DataV，和常见的H5制作工具，灵活且功能实用。\r\n\r\n前端流程设计：\r\nhttps://kdocs.cn/l/sKOMtserU?f=101\r\n[文档] 大数据平台构建流程.pom\r\n\r\n### 【project】打造一套完整的访客系统，从前端到后台\r\n\r\n> 应用场景：从用户端的访客预约信息提交，到信息管理，再到线下访客机的实体验证，认证反馈。从软件到硬件，用户端到现场端，解决这一问题。\r\n\r\n1. 用户角色：访客信息录入—— H5、小程序、pc web 管理端\r\n\r\n2. 访客角色：访客信息查询——H5、小程序\r\n\r\n3. 访客机：访客角色验证、访客卡领取、用户&访客（团）批处理\r\n\r\n技术实现：\r\n\r\n前端：vue + vuex + taro = H5 & 小程序； react 管理端\r\n\r\n后台：nodejs + mangoDB\r\n\r\n<!-- 访客系统   会议预定系统   场馆预订系统  圣诞晚会抽票  摇奖系统  商品选购下订单  数据展示定制化平台 -->\r\n\r\n<!-- ### 【project】赛车拉力***\r\n实现平台：微信小游戏，实时对战3v3，2v2，个人障碍赛，个人竞速赛\r\n\r\n故事一：巴音布鲁克赛道\r\n\r\n故事二：罪恶都市赛道\r\n\r\n故事伞：乡村赛道\r\n\r\n实现技术栈：JS，webscoket，webgl3D，wechat SDK，nodejs，重力场\r\n\r\n> 模型设计、技术选型可以参考 https://bruno-simon.com/  ，操控可以参考微信小游戏模式、王者荣耀、吃鸡模式\r\nhttps://greensock.com/showcase/\r\n\r\n -->\r\n\r\n### 【project】网址收藏夹\r\n类似百度网址个性页。\r\n功能列表：\r\n\r\n1、可以导入html格式的网址收藏夹\r\n\r\n2、可以手动添加、删除、修改、查询，管理已有的收藏夹地址\r\n\r\n3、可以灵活拖动网址\r\n\r\n4、每个网址会自动检测该地址是否可以打开，若可以打开，则提取该网址ico作为图标\r\n\r\n5、所见即所得的交互方式\r\n\r\n> 可参考百度网址收藏夹\r\nhttps://www.baidu.com/\r\nhttps://withpinbox.com/\r\nhttp://yijee.esgao.cn/profile\r\nchrome://bookmarks/\r\nhttp://www.linkwebll.com/\r\nhttp://www.wzgxpt.com/\r\nhttp://www.lian81.com/lianjie7891/\r\nhttps://www.zhihu.com/question/21261508\r\n\r\n\r\n\r\n### 【project】工作日历系统\r\n可以用来管理日常工作的录入，类似mac系统自带的日历系统和google日历\r\n\r\n常用功能：\r\n\r\n1、工作颗粒度录入，以及该工作的项目归属\r\n\r\n2、团队项目管理\r\n\r\n3、数据统计分析、报表输出\r\n\r\n3、集成工时系统\r\n\r\n> 参考google日历\r\nhttps://calendar.google.com/calendar/r \r\n\r\n> https://fullcalendar.io/  \r\n> https://ui.toast.com/tui-calendar\r\n> https://element.eleme.cn/#/zh-CN/component/calendar\r\n> \r\n\r\n<!-- ### 【project】 精灵盒子\r\n\r\n一种集成内置全息投影、AR效果的，正方体，大概45cm * 45cm * 45cm，里面的游戏，可以渲染成为场景，沙盘，建筑或者塔防游戏，可以给人以AR或者全息投影的真实效果，通过内置计算模块和六面投影屏幕，从外向内看到的就是很逼真的场景，用户可以通过手机app、或者游戏手柄来操作里面的人物进行任务闯关，值得实现的游戏有《纪念碑谷》、《生化危机》 -->\r\n\r\n### 【project】 手势识别、声音识别来操作窗帘\r\n\r\n用手挥动来开关窗帘。用屋内摄像头捕捉识别人体手势，传送到后台进行分析，通过机器学习、手势识别技术，分析出是哪一种手势，再传出指令调动窗帘上安装的电机执行打开或者收起的效果。\r\n> 人体手势=>摄像头=>后端计算识别手势指令=>发出开关指令=>电机转动\r\n\r\n用声音来操控窗帘。\r\n> 人体声音=>麦克风=>后端计算识别声音指令=>发出开关指令=>电机转动\r\n\r\n从前端传输到后端的以中心计算的设计模式，也可以改为终端识别即可执行指令，即将摄像模块、计算模块、控制模块集成一体到终端中，在终端中完成一系列的操作。不需要进行网络传输，保证在离线模式下也可以正常使用。在大规模识别计算场景中，将计算服务放在终端，也是一种很不错的模式，远端只需要定期对终端进行服务升级。\r\n\r\n### 【project】 AI迷宫终结者\r\n\r\n先对迷宫算法进行策略算法实现，通过Tensorflow框架进行迷宫地图的算法模型训练，让其能力演变为对任意迷宫地图都能够做到图形识别，提取迷宫模型骨骼图亦或是点阵图，达到算法能够识别进行的程度。交互方式上，从起点或者图中任意一点划出一条红线连接到终点。\r\n\r\n> 用户上传迷宫图=>迷宫模型提取=>算法计算最优路径=>绘制路线\r\n<img src=\"https://img-bbs.csdn.net/upload/201508/04/1438700761_871230.jpg\">\r\n<!-- \r\nhttps://tensorflow.google.cn/js/models\r\nhttp://blog.sciencenet.cn/blog-671857-567654.html\r\nhttps://www.samyzaf.com/ML/rl/qmaze.html  \r\nhttp://www.webhek.com/apps/PathFinding/\r\n-->\r\n\r\n### 【project】 AI五子棋\r\n\r\n使用CSS3开启GPU硬件加速提升网站动画渲染性能\r\n2014年03月12日 | 彬Go\r\nhttp://blog.bingo929.com/transform-translate3d-translatez-transition-gpu-hardware-acceleration.html\r\n\r\n\r\n纯JS 智能五子棋 初级版 \r\nhttp://blog.sina.com.cn/s/blog_74d6cedd0100ywow.html\r\n纯JS 智能五子棋 out版 \r\nhttp://blog.sina.com.cn/s/blog_74d6cedd0100ywhv.html\r\n\r\n纯JS开发五子棋游戏，JavaScript五子棋初级版\r\nhttp://www.veryhuo.com/down/html/44497.html\r\n\r\n三三禁手\r\nhttps://zhidao.baidu.com/question/17134706.html\r\n\r\n### 【project】 翰林贴，按笔画书写汉字，带动画\r\n\r\nhttp://bishun.shufaji.com/0x963F.html\r\n\r\n### 【星图】 寻找星座的位置\r\n\r\n构建webgl版的3D找星座网站\r\n\r\n### 【音乐聚合】 各大类音乐网站资源的聚合页\r\n\r\n提供一个可以播放的界面，并展示来源网站\r\n\r\n优化推荐算法，来提升推荐的效果\r\n\r\nhttp://yuhuiyu.com/paihangbang/jingdian/\r\nhttp://www.zuiqin.com/?name=%E5%90%BB%E5%88%AB&type=netease\r\nhttp://ww1.azp2.com/mp3/\r\n",
      "data": {
        "title": "小项目",
        "date": "2020-05-05 22:44:23",
        "tags": [
          "小项目"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "project"
    },
    {
      "content": "### 【Good Code】\r\n\r\n* [DataEditH5](http://souxy.com/demo/edit.html)\r\n\r\n### 【Old Idea】\r\n* 2011年 -- 基于地理位置的LBS商户美食推荐系统\r\n* 2012年 -- 第四方物流与供应链系统（类似现在的滴滴货车和货嘀运力调度中心http://data.tf56.com/huodi.html?city=1）\r\n* 2012年 —- 知识共享系统\r\n\r\n\r\n### 【project】数据可视化配置平台\r\n基于react + dva + redux的可视化配置数据平台的前端工作流程设计方案（不断完善中）\r\n\r\n解决需求：\r\n\r\n+ 解决管理后台动态可配置\r\n\r\n+ 解决数据图表动态添加修改可配置\r\n\r\n+ 解决数据源与数据图表可配置\r\n\r\n> 落地产品：类似阿里DataV，和常见的H5制作工具，灵活且功能实用。\r\n\r\n前端流程设计：\r\nhttps://kdocs.cn/l/sKOMtserU?f=101\r\n[文档] 大数据平台构建流程.pom\r\n\r\n### 【project】打造一套完整的访客系统，从前端到后台\r\n\r\n> 应用场景：从用户端的访客预约信息提交，到信息管理，再到线下访客机的实体验证，认证反馈。从软件到硬件，用户端到现场端，解决这一问题。\r\n\r\n1. 用户角色：访客信息录入—— H5、小程序、pc web 管理端\r\n\r\n2. 访客角色：访客信息查询——H5、小程序\r\n\r\n3. 访客机：访客角色验证、访客卡领取、用户&访客（团）批处理\r\n\r\n技术实现：\r\n\r\n前端：vue + vuex + taro = H5 & 小程序； react 管理端\r\n\r\n后台：nodejs + mangoDB\r\n\r\n<!-- 访客系统   会议预定系统   场馆预订系统  圣诞晚会抽票  摇奖系统  商品选购下订单  数据展示定制化平台 -->\r\n\r\n<!-- ### 【project】赛车拉力***\r\n实现平台：微信小游戏，实时对战3v3，2v2，个人障碍赛，个人竞速赛\r\n\r\n故事一：巴音布鲁克赛道\r\n\r\n故事二：罪恶都市赛道\r\n\r\n故事伞：乡村赛道\r\n\r\n实现技术栈：JS，webscoket，webgl3D，wechat SDK，nodejs，重力场\r\n\r\n> 模型设计、技术选型可以参考 https://bruno-simon.com/  ，操控可以参考微信小游戏模式、王者荣耀、吃鸡模式\r\nhttps://greensock.com/showcase/\r\n\r\n -->\r\n\r\n### 【project】网址收藏夹\r\n类似百度网址个性页。\r\n功能列表：\r\n\r\n1、可以导入html格式的网址收藏夹\r\n\r\n2、可以手动添加、删除、修改、查询，管理已有的收藏夹地址\r\n\r\n3、可以灵活拖动网址\r\n\r\n4、每个网址会自动检测该地址是否可以打开，若可以打开，则提取该网址ico作为图标\r\n\r\n5、所见即所得的交互方式\r\n\r\n> 可参考百度网址收藏夹\r\nhttps://www.baidu.com/\r\nhttps://withpinbox.com/\r\nhttp://yijee.esgao.cn/profile\r\nchrome://bookmarks/\r\n\r\n\r\n### 【project】工作日历系统\r\n可以用来管理日常工作的录入，类似mac系统自带的日历系统和google日历\r\n\r\n常用功能：\r\n\r\n1、工作颗粒度录入，以及该工作的项目归属\r\n\r\n2、团队项目管理\r\n\r\n3、数据统计分析、报表输出\r\n\r\n3、集成工时系统\r\n\r\n> 参考google日历\r\nhttps://calendar.google.com/calendar/r \r\n\r\n> https://fullcalendar.io/  \r\n> https://ui.toast.com/tui-calendar\r\n\r\n<!-- ### 【project】 精灵盒子\r\n\r\n一种集成内置全息投影、AR效果的，正方体，大概45cm * 45cm * 45cm，里面的游戏，可以渲染成为场景，沙盘，建筑或者塔防游戏，可以给人以AR或者全息投影的真实效果，通过内置计算模块和六面投影屏幕，从外向内看到的就是很逼真的场景，用户可以通过手机app、或者游戏手柄来操作里面的人物进行任务闯关，值得实现的游戏有《纪念碑谷》、《生化危机》 -->\r\n\r\n### 【project】 手势识别、声音识别来操作窗帘\r\n\r\n用手挥动来开关窗帘。用屋内摄像头捕捉识别人体手势，传送到后台进行分析，通过机器学习、手势识别技术，分析出是哪一种手势，再传出指令调动窗帘上安装的电机执行打开或者收起的效果。\r\n> 人体手势=>摄像头=>后端计算识别手势指令=>发出开关指令=>电机转动\r\n\r\n用声音来操控窗帘。\r\n> 人体声音=>麦克风=>后端计算识别声音指令=>发出开关指令=>电机转动\r\n\r\n从前端传输到后端的以中心计算的设计模式，也可以改为终端识别即可执行指令，即将摄像模块、计算模块、控制模块集成一体到终端中，在终端中完成一系列的操作。不需要进行网络传输，保证在离线模式下也可以正常使用。在大规模识别计算场景中，将计算服务放在终端，也是一种很不错的模式，远端只需要定期对终端进行服务升级。\r\n\r\n### 【project】 AI迷宫终结者\r\n\r\n先对迷宫算法进行策略算法实现，通过Tensorflow框架进行迷宫地图的算法模型训练，让其能力演变为对任意迷宫地图都能够做到图形识别，提取迷宫模型骨骼图亦或是点阵图，达到算法能够识别进行的程度。交互方式上，从起点或者图中任意一点划出一条红线连接到终点。\r\n\r\n> 用户上传迷宫图=>迷宫模型提取=>算法计算最优路径=>绘制路线\r\n<img src=\"https://img-bbs.csdn.net/upload/201508/04/1438700761_871230.jpg\">\r\n<!-- \r\nhttps://tensorflow.google.cn/js/models\r\nhttp://blog.sciencenet.cn/blog-671857-567654.html\r\nhttps://www.samyzaf.com/ML/rl/qmaze.html  \r\nhttp://www.webhek.com/apps/PathFinding/\r\n-->\r\n\r\n### 【project】 AI五子棋\r\n\r\n使用CSS3开启GPU硬件加速提升网站动画渲染性能\r\n2014年03月12日 | 彬Go\r\nhttp://blog.bingo929.com/transform-translate3d-translatez-transition-gpu-hardware-acceleration.html\r\n\r\n\r\n纯JS 智能五子棋 初级版 \r\nhttp://blog.sina.com.cn/s/blog_74d6cedd0100ywow.html\r\n纯JS 智能五子棋 out版 \r\nhttp://blog.sina.com.cn/s/blog_74d6cedd0100ywhv.html\r\n\r\n纯JS开发五子棋游戏，JavaScript五子棋初级版\r\nhttp://www.veryhuo.com/down/html/44497.html\r\n\r\n三三禁手\r\nhttps://zhidao.baidu.com/question/17134706.html\r\n\r\n### 【project】 翰林贴，按笔画书写汉字，带动画\r\n\r\nhttp://bishun.shufaji.com/0x963F.html\r\n\r\n### 【星图】 寻找星座的位置\r\n\r\n构建webgl版的3D找星座网站\r\n\r\n### 【音乐聚合】 各大类音乐网站资源的聚合页\r\n\r\n提供一个可以播放的界面，并展示来源网站\r\n\r\n优化推荐算法，来提升推荐的效果\r\n\r\nhttp://yuhuiyu.com/paihangbang/jingdian/\r\nhttp://www.zuiqin.com/?name=%E5%90%BB%E5%88%AB&type=netease\r\nhttp://ww1.azp2.com/mp3/\r\n",
      "data": {
        "title": "小项目",
        "date": "2020-05-05 22:44:23",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "xiao-xiang-mu"
    },
    {
      "content": "\r\n1、生成域名对应的证书\r\n\r\n2、在ng服务器中创建一个ssl的文件夹来存放证书文件和密钥文件\r\n\r\n3、修改nginx.conf配置，将ssl_certificate 和 ssl_certificate_key 分别指向对应的路径\r\n\r\n4、到ng中，nginx -t 测试是否配置成功\r\n\r\n5、重启ng，nginx -s reload，即可\r\n\r\nhttps://cloud.tencent.com/document/product/400/35244\r\n",
      "data": {
        "title": "Nginx 服务器安装HTTPS证书",
        "date": "2020-05-05 22:37:32",
        "tags": [
          "Nginx"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "nginx-fu-wu-qi-an-zhuang-https-zheng-shu"
    },
    {
      "content": "\r\n全流程走通，抓包happy\r\n可用在微信小程序的https请求中抓包\r\n移动端也有好用的抓包工具 Stream\r\n\r\nhttps://www.jianshu.com/p/933d78091d90",
      "data": {
        "title": "mac下使用Charles抓包",
        "date": "2020-05-05 22:36:58",
        "tags": [
          "抓包"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mac-xia-shi-yong-charles-zhua-bao"
    },
    {
      "content": "\r\n通常一个页面对应一个class，而同一个class里面的form是公用同一个作用域，当需要在一个页面中操作多个不同的class时，就会遇到一些问题：\r\n比如：两个表单都调用了``validateFields`` 时，则会互相影响。``getFieldValue``、`` getFieldsValue`` 虽然可以针对不同的 ``getFieldDecorator``进行取值，但是在表单提交校验的时候，这会连带另一个form一起校验，这样不太友好。\r\n\r\n一般的处理方式，可以是使用一个页面中创建两个class，分别放置一个form，这样表单作用域就会各自进行校验。如果需要两个form需要数据交互的校验，则需要使用事件传递等方式通过组件之间通信的props传值，不是很方便；这里还可以使用高阶组件``wrappedComponentRef``来操作；\r\n\r\n```\r\nclass CustomizedForm extends React.Component { ... }\r\n\r\n// use wrappedComponentRef\r\nconst EnhancedForm =  Form.create()(CustomizedForm);\r\n<EnhancedForm wrappedComponentRef={(form) => this.form = form} />\r\nthis.form // => The instance of CustomizedForm\r\n```\r\n经过``Form.creat``包装之后的组件将会自带 ``this.props.form``属性",
      "data": {
        "title": "react 高阶组件的用法与一个页面处理多个表单的问题",
        "date": "2020-05-05 22:36:24",
        "tags": [
          "react"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-gao-jie-zu-jian-de-yong-fa-yu-yi-ge-ye-mian-chu-li-duo-ge-biao-dan-de-wen-ti"
    },
    {
      "content": "\r\n* 校验11位手机号码  `reg=/^[1][3,4,5,7,8][0-9]{9}$/`\r\n```javascript\r\nfunction checkPhone(val){\r\n  var reg=/^[1][3,4,5,7,8][0-9]{9}$/\r\n  if (!myreg.test($poneInput.val())) {  \r\n      return false;  \r\n  }\r\n  return true;  \r\n}\r\n```\r\n* 校验短信验证码：`/[0-9]{6}/`\r\n\r\n* 身份证校验: `/^[1-9]\\d{5}(18|19|20|(3\\d))\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/`",
      "data": {
        "title": "正则表达式常用校验规则",
        "date": "2020-05-05 22:35:16",
        "tags": [
          "正则"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zheng-ze-biao-da-shi-chang-yong-xiao-yan-gui-ze"
    },
    {
      "content": "\r\n```\r\n查看进程  ps -ef|grep nginx\r\n\r\n关闭进程  kill -QUIT 或者 nginx -s stop\r\n\r\n启动服务  systemctl start nginx\r\n\r\n编辑保存 :x\t\t:wq保存退出\t\t:wq!保存强制退出\r\n\r\n删除行 Esc -- 两下d\r\n\r\nng重启 nginx -s reload，重启之前 -t 检测\r\n\r\nng检测 nginx -t，如果-t之后报错可以 nginx -c /etc/nginx/nginx.conf ，再 重启\r\n\r\n创建文件 touch xxx.xx\r\n\r\n删除文件 rm  xxx.xx   --  y\r\n\r\n打开编辑文件 vim \r\n\r\n```\r\n 更多指令：https://blog.csdn.net/jincf2011/article/details/6363301 \r\n",
      "data": {
        "title": "Linux常用操作",
        "date": "2020-05-05 22:33:59",
        "tags": [
          "Linux"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "linux-chang-yong-cao-zuo"
    },
    {
      "content": "\r\nReact处理数据时经常遇到数据是由接口请求回来，每次触发props更新都会导致重新render，如果需要的数据是需要构造出新的数据，则一般会采用 ``Array``的push方法，但是由于多次的render导致多次push导致数据重复，改为``Set()``数据类型则会自动过滤到重复的数据：\r\n\r\n**添加与删除**\r\n\r\n``Set()`` 添加数据用 `.add()`方法，删除数据用 `.delete()`\r\n> `add`方法在添加数据时一次只能添加一条数据，`Array`在push时是可以一次添加多条数据\r\n![](https://www.tuziki.com/post-images/1588689109315.png)\r\n![](https://www.tuziki.com/post-images/1588689123302.jpg)\r\n\r\n``Array`` 添加数据用 `.push()`添加数据到数组尾部。\r\n向数组的首位添加数据可以用`.unshift()`\r\n\r\n合并多个数据用`.concat()` 将一个或者多个数组进行合并成一个新的数组，注意合并数组时被合并的数组数据会自动加到新数组的后面：\r\n![](https://www.tuziki.com/post-images/1588689149697.png)\r\n\r\n`Array`在删除时，有多种办法：\r\n\r\n* `pop()` 删除数组最后一个元素并返回它\r\n* `shift()` 删除数组第一个元素并返回它\r\n* `arr[arr.length-1]` 选中数组最后一个数据\r\n* `arr.slice(-1) ` 选中指定位置的元素及它以后的所有元素并返回，-1则是倒数第一个，`arrB = arrA.slice()` 为复制数组A给B\r\n* `arr.splice(n,m)` 从第n个元素开始删除原数组中m个元素，并返回这m个元素，`arr.splice(1,arr.length)`为清空数组\r\n\r\n**清空数组**\r\n* `arr.splice(0,arr.length)` 使用splice函数\r\n* `arr.length = 0` 给数组的length赋值为0\r\n* `arr = []` 直接赋予新数组 []\r\n\r\n*效率比较：*\r\n```\r\n  let a = [];\r\n  let b = [];\r\n  let c = [];\r\n  for (let i = 0; i < 10000; i++) {\r\n    a.push(i);\r\n  }\r\n  console.time('splice');\r\n  a.splice(0, a.length);\r\n  console.timeEnd('splice');\r\n\r\n  for (let i = 0; i < 10000; i++) {\r\n    b.push(i);\r\n  }\r\n  console.time('length');\r\n  b.length = 0;\r\n  console.timeEnd('length');\r\n\r\n  for (let i = 0; i < 10000; i++) {\r\n    c.push(i);\r\n  }\r\n  console.time('赋值[]');\r\n  c = [];\r\n  console.timeEnd('赋值[]');\r\n```\r\n结果：\r\n```\r\nsplice: 1757.174072265625ms\r\nlength: 0.06396484375ms\r\n赋值[]: 0.095947265625ms\r\n```\r\n多次测试发现第二种方式最快，第三种其次，大数据量下 第一种最慢。\r\n\r\n> 数组的去重 和 排序\r\n\r\n``a = Array.from(new Set(a)).sort()`` 先去重，再排序",
      "data": {
        "title": "Set() 与 Array() 比较",
        "date": "2020-05-05 22:31:23",
        "tags": [
          "Array"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "set-yu-array-bi-jiao"
    },
    {
      "content": "\r\n> 业务场景：多种状态判断的显示执行语句，需要优化js的嵌套if语句。\r\n\r\n```JavaScript\r\n// 操作（SUBMIT = 接件；EXAMINE = 审核；SITE_CHECK = 现场核验；WAIT_DISTRIBUTE = 分发；FOLLOW = 办理；WAIT_GET = 现场领件；APPRAISE = 查看评价）\r\n\r\n  if (code === 'SUBMIT') {\r\n    code = 'default'\r\n  } else if (code === 'EXAMINE') {\r\n    code = 'processing'\r\n  } else if (code === 'SITE_CHECK') {\r\n    code = 'warning'\r\n  } else if (code === 'WAIT_DISTRIBUTE') {\r\n    code = 'warning'\r\n  } else if (code === 'FOLLOW') {\r\n    code = 'warning'\r\n  } else if (code === 'WAIT_GET') {\r\n    code = 'warning'\r\n  } else if (code === 'PASSED') {\r\n    code = 'success'\r\n  } else if (code === 'APPRAISE') {\r\n    code = 'success'\r\n  } else if (code === 'NOT_PASSED') {\r\n    code = 'error'\r\n  } else {\r\n    code = 'default'\r\n  }\r\n  return <Badge status={code} text={name} />\r\n```\r\n\r\n这里可以直接将多个 ``if... else if ...`` 语句改写为 ``switch`` ,但是这样写其实并没有太多的优化，则需要考虑更加有效率的方法，避免过多的条件检查，可以使用 ``object``\r\n\r\n```JavaScript\r\n  const codeList = {\r\n    SUBMIT: 'default',\r\n    EXAMINE: 'processing',\r\n    SITE_CHECK: 'warning',\r\n    WAIT_DISTRIBUTE: 'warning',\r\n    FOLLOW: 'warning',\r\n    WAIT_GET: 'warning',\r\n    PASSED: 'success',\r\n    APPRAISE: 'success',\r\n    NOT_PASSED: 'error'\r\n  }\r\n  code = codeList[code]\r\n  return <Badge status={code} text={name} />\r\n```",
      "data": {
        "title": "优化嵌套的条件判断语句",
        "date": "2020-05-05 22:30:36",
        "tags": [
          "代码优化"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "you-hua-qian-tao-de-tiao-jian-pan-duan-yu-ju"
    },
    {
      "content": "```   JavaScript   \r\nrender: (text, record) =>{\r\n    let snArray = [];\r\n    snArray = text.split('+');\r\n    let br = <br/>;\r\n    let result = null;\r\n    if (snArray.length < 2) {\r\n        return text;\r\n    }\r\n    for (let i = 0; i < snArray.length; i++) {\r\n        if (i === 0) {\r\n            result = snArray[i];\r\n        } else {\r\n            result = (<span>{result}{br}{snArray[i]}</span>);\r\n        }\r\n    }\r\n    return <div>{result}</div > ;\r\n}\r\n```",
      "data": {
        "title": "react ant 中处理table列内容太多换行",
        "date": "2020-05-05 22:30:03",
        "tags": [
          "react"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-ant-zhong-chu-li-table-lie-nei-rong-tai-duo-huan-xing"
    },
    {
      "content": "\r\n1.1 Title 优化           \r\n首页：Tencent AI Lab 官网\r\n频道页：频道名 _ Tencent AI Lab 官网\r\n详情页：文章名1 _ 频道名 _ Tencent AI Lab 官网\r\n\r\n1.2 description 优化           \r\nDescription 为必要描述，最好是在当前页的编辑页添加对应的description，这里后台可以专门增加一个输入框，如果不输入，则后台应自动抓取文章的内容设置到这里，抓取的范围为其长度pc端大概为78个中文，移动端为50个，超过则会截断为省略号。\r\n如果当前页，没有适合做description的，则抓取网站主页的描述即可。\r\n\r\n1.3 keywords 优化           \r\nKeywords首页则为我们当前已经设置的；\r\n频道页可以做后台输入，没有设计，则为手动编辑html或者为首页keywords即可；\r\n详情页应该只能抓取文章中的关键词，没有则用户输入关键词，没有，则设为首页keywords即可；\r\n\r\n1.4 url 优化           \r\n静态化，\r\n越短越好，避免太多参数，目录层次尽量少\r\n文件及目录名具描述性，例如\r\nhttp://www.xxx.com/hk/ailab_proj/news/news-list.html 新闻频道-新闻列表\r\nhttp://www.xxx.com/hk/ailab_proj/news/news.html 新闻频道-新闻详情页\r\nhttp://www.xxx.com/hk/ailab_proj/papers/paper2.html 论文频道-论文详情页\r\nURL链接的最后，最好是加上这篇论文的标题，中文是中文标题，英文用英文标题；\r\n字母全部小写\r\n连词符使用-而不是_\r\nURL中包括关键词(中文除外)\r\n目录形式而非文件形式\r\n\r\n1.5 页面结构 优化           \r\nImg标签需要提供alt=””属性设置\r\n\r\n...\r\n(未完待续)",
      "data": {
        "title": "SEO优化",
        "date": "2020-05-05 22:29:18",
        "tags": [
          "SEO"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "seo-you-hua"
    },
    {
      "content": "网上的教程比较坑，且很老不用看了。\r\n\r\n1. 在github上构建好自己的网站，并在master分支下的Settings\r\n———— Repository name ，修改名称为 tutusiji.github.io\r\n\r\n2. 在下面的 GitHub Pages 里面设置自定义域名为 tuziki.com，并在master分支下面创建文件CNAME内容为 tuziki.com\r\n\r\n3. 到域名解析商那里修改域名解析：改 `CNAME\twww 到 tutusiji.github.io`，改  `CNAME\t * 到 tutusiji.github.io` 或者再加上 `CNAME\t@ 到 tutusiji.github.io `\r\n\r\n> 到这里域名基本可以访问，但是浏览器会提示安全限制，就是证书没有得到安全认证。去找一个可以提供免费SSL证书的域名商转接一下就好。\r\n\r\n4. Cloudflare (https://dash.cloudflare.com) 提供的免费SSL。进行下面几步操作：\r\n    1. 创建CloudFlare帐户，并添加网站\r\n    2. 输入域名、点击扫描、进入面板页面、并选择免费计划，下一步~\r\n    3. 到DNS页面设置域名解析，如图：\r\n![](https://www.tuziki.com/post-images/1588688928570.png)\r\n    4. 到Page Rules页面设置域名重定向：选择 Forwarding URL -- 301\r\n    ```\r\n    http://tuziki.com/ => https://tuziki.com\r\n    http://www.tuziki.com/ => https://tuziki.com\r\n    http://*.tuziki.com/* => https://*.tuziki.com/*\r\n    ```\r\n\r\n5. Done and Refresh.",
      "data": {
        "title": "个人域名绑定github并解锁https安全限制指北",
        "date": "2020-05-05 22:28:19",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ge-ren-yu-ming-bang-ding-github-bing-jie-suo-https-an-quan-xian-zhi-zhi-bei"
    },
    {
      "content": "\r\n> some() 会遍历数组中第一个与条件符合的并返回true\r\n\r\n```JavaScript\r\n// 1. some使用 es6新增方法，和es5的数组forEach类似\r\nvar data = [\r\n    { id: 1, name: 'wzj' },\r\n    { id: 2, name: 'zr' },\r\n    { id: 3, name: 'dxy' }\r\n];\r\n\r\n// 找出 id 为 2 的对象\r\nvar result = data.some(function (value) {\r\n    // 若没有返回值，则会一直循环遍历，类似forEach\r\n    console.log(value);\r\n\r\n    return value.id == 2;\r\n});\r\n\r\nconsole.log(result);//true\r\n\r\n```\r\n> find: 快速查找返回对象中匹配到key的item\r\n\r\n```JavaScript\r\nconst dataItem = DataObject.find(item => item.key === \"keys\")\r\n```\r\n\r\n> find: 合并两个数组中的目标值\r\n\r\n```\r\nconst listA =[{\r\n      id: 'a1',\r\n      type: 'yyy1'\r\n    },{\r\n      id: 'a2',\r\n      type: 'yyy2'\r\n    },{\r\n      id: 'a3',\r\n      type: 'yyy3'\r\n    }]\r\nconst listB =[{\r\n      id: 'a1',\r\n      name: 'xxx1'\r\n    },{\r\n      id: 'a2',\r\n      name: 'xxx2'\r\n    },{\r\n      id: 'a3',\r\n      name: 'xxx3'\r\n    }]\r\n    listA.map(i=>{\r\n      const targetItem = listB.find(item =>item.id === i.id )\r\n      i.name = targetItem.name\r\n      return listA\r\n    })\r\n\r\n    console.log( listA)\r\n```\r\n![](https://www.tuziki.com/post-images/1588688590104.png)",
      "data": {
        "title": "JS数组常用方法总结 some()、every()、find()、findIndex()、filter()、includes()、map()、fill()",
        "date": "2020-05-05 22:22:22",
        "tags": [
          "数组"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "js-shu-zu-chang-yong-fang-fa-zong-jie-someeveryfindfindindexfilterincludesmapfill"
    },
    {
      "content": "适用于业务中的时间耗时展示，处理成对应的时分秒天。主要点在于对时分秒的分开取模上面，将取到的模换算成对应的时分秒或者是进行条件区间判断，比如：一分钟以内展示秒，超过30秒显示1分钟，超过、超过一天或者1小时则不显示秒\r\n```JavaScript\r\nfunction showTime(time){\r\n    let dateTimes = ''\r\n    const ss = time\r\n    const days = Math.round(ss / (60 * 60 * 24))\r\n    const hours = Math.round((ss % (60 * 60 * 24)) / (60 * 60))\r\n    const minutes = parseInt((ss % (60 * 60)) / 60, 10)\r\n    const seconds = ss % 60\r\n    if (days > 1) {\r\n        // dateTimes = `${days}天${hours}小时${minutes}分${seconds}秒`\r\n        dateTimes = `${days}天${hours}小时${minutes}分`\r\n    } else if (hours > 1) {\r\n        dateTimes = `${hours}小时${minutes}分`\r\n    } else if (minutes > 60) {\r\n        dateTimes = `${minutes}分${seconds}秒`\r\n    } else {\r\n        dateTimes = `${seconds}秒`\r\n    }\r\n    return dateTimes\r\n}\r\n```\r\n\r\n",
      "data": {
        "title": "对时间格式的处理方法",
        "date": "2020-05-05 21:36:27",
        "tags": [
          "js时间处理"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dui-shi-jian-ge-shi-de-chu-li-fang-fa"
    },
    {
      "content": "\r\n应用场景在于角色管理菜单树管理，这种多层`<tree>`杂糅到一起的地方，antdesign 中对`<tree>`的定义是固定的，只能渲染以这种格式：\r\n\r\n\r\n```language-javascript\r\n  {\r\n      title: '0-1',\r\n      key: '0-1',\r\n      children: [\r\n        { title: '0-1-0-0', key: '0-1-0-0' },\r\n        { title: '0-1-0-1', key: '0-1-0-1' },\r\n        { title: '0-1-0-2', key: '0-1-0-2' },\r\n      ],\r\n    }\r\n```\r\n\r\n且children的层级单一，往往后端返回的接口数据是非常多的层级，并不能立即使用。则需要对每一个层级进行单独的处理，再组合成 `<tree>` 组件所需要的格式：\r\n```JavaScript\r\n// 渲染树 第一级\r\n  renderTreeNodes = data => {\r\n    if (data) {\r\n      const render = data.map((item, index) => {\r\n        if (item.menuList) {\r\n          return (\r\n            <TreeNode title={item.moduleName} key={'0' + item.moduleId} dataRef={item}>\r\n              {this.renderTreeNodesChildren(item.menuList)}\r\n            </TreeNode>\r\n          );\r\n        }\r\n        return <TreeNode {...item} key={'0' + item.moduleId} />;\r\n      });\r\n      return render;\r\n    }\r\n  };\r\n  // 渲染树 第二级\r\n  renderTreeNodesChildren = data =>\r\n    data &&\r\n    data.map((item, index) => {\r\n      if (item.childrenMenuList) {\r\n        return (\r\n          <TreeNode title={item.menuName} key={item.menuId} dataRef={item}>\r\n            {item.childrenMenuList.length > 0\r\n              ? this.renderTreeNodesChildren(item.childrenMenuList)\r\n              : this.renderTreePermissionList(item.permissionList)}\r\n          </TreeNode>\r\n        );\r\n      }\r\n      return <TreeNode {...item} key={item.menuId} />;\r\n    });\r\n  // 渲染树 第三级\r\n  renderTreePermissionList = data => {\r\n    if (data) {\r\n      // console.log({ data });\r\n      const render = data.map(item => {\r\n        if (item) {\r\n          return <TreeNode title={item.funcName} key={item.funcId} dataRef={item} />;\r\n        }\r\n        return <TreeNode {...item} key={item.funcId} />;\r\n      });\r\n      return render;\r\n    }\r\n  };\r\n  ```\r\n而对于 `<tree>`组件中 标注已选中checkbox时，需要在 componentWillUnmount() 就请求接口数据 ` this.findList(response.moduleList) ` 处理完成之后 `this.setState({\r\nfuncIdList: []})`及时更新 `<tree>`数据：\r\n```JavaScript\r\n // 筛选递归\r\n  findList = data => {\r\n    // const { allIdList, funcIdList } = this.state;\r\n    // console.log('findList ', data);\r\n    for (let i = 0; i < data.length; i++) {\r\n      const item = data[i];\r\n      if (item.permissionList && item.permissionList.length > 0) {\r\n        item.permissionList.map((item, index) => {\r\n          allIdList.push(item.funcId);\r\n          if (Number(item.grant) === 1) {\r\n            funcIdList.push(item.funcId);\r\n          }\r\n        });\r\n      } else {\r\n        if (item.menuId) {\r\n          allIdList.push(item.menuId);\r\n        } else {\r\n          allIdList.push('0' + item.moduleId);\r\n        }\r\n      }\r\n      if (item.menuList && item.menuList.length > 0) {\r\n        item.menuList.map((item, index) => {\r\n          allIdList.push(item.menuId);\r\n        });\r\n        this.findList(item.menuList);\r\n      }\r\n      if (item.childrenMenuList && item.childrenMenuList.length > 0) {\r\n        item.childrenMenuList.map((item, index) => {\r\n          allIdList.push(item.menuId);\r\n        });\r\n        this.findList(item.childrenMenuList);\r\n      }\r\n    }\r\n    const allIdDone = Array.from(new Set(allIdList));\r\n\r\n    this.setState({\r\n      checkedKeys: funcIdList,\r\n      expandedKeys: allIdDone,\r\n      allIdList: allIdDone\r\n    });\r\n    // console.log('allIdList', allIdDone);\r\n    // console.log('funcIdList', funcIdList);\r\n  };\r\n```\r\n",
      "data": {
        "title": "React antdesign 渲染多层级菜单树的递归处理优化",
        "date": "2019-06-05 22:26:35",
        "tags": [
          "react",
          "递归"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "react-antdesign-xuan-ran-duo-ceng-ji-cai-dan-shu-de-di-gui-chu-li-you-hua"
    },
    {
      "content": "Mac管理员权限下发 sudo jamf -removeframework\r\n\r\n快速启动本地服务 python -m SimpleHTTPServer\r\n\r\nnpm源切换   nrm ls、nrm test、nrm use taobao、nrm add、nrm del \r\n\r\nchrome解决http自动跳转https问题 chrome://net-internals/#hsts\r\n\r\n腾讯视频文件qlv转mp4文件 ``copy/b *.tdl 1.mp4`` 保存为qlv2mp4.bat 文件，在到qlv所在目录执行\r\n",
      "data": {
        "title": "常用指令集",
        "date": "2019-05-05 11:39:52",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "chang-yong-zhi-ling-ji"
    },
    {
      "content": "> 欢迎来到我的小站呀，很高兴遇见你！🤝\r\n\r\nweb前端开发工程师。 \r\n🐧🐧: 123507356\r\n<!-- \r\n学历：本科，学士学位，武汉大学行政管理专业，2015-2018年自考毕业。\r\n专科，武汉科技大学计算机信息管理专业，2009-2012年全日制毕业，在校期间曾组建软件网站开发团队。\r\n-->\r\n**专业能力**\r\nUI开发：熟练掌握Html5、Css3、Less、Sass、Svg、Canvas等前端基础技术，能够使用基于Vue和React的UI组件库等工具实现美观、高效、兼容的页面布局和交互效果，并有UI组件库开发经验。\r\n前端工程化：熟悉Gulp、Swig、Webpack等前端构建工具，能够使用Svn、Git等版本控制工具进行代码管理和协作开发。\r\n前端框架技术： 熟练使用JavaScript、ES6 语法，熟悉React/Redux/Router、DvaJs、Vue/Vuex/Vue-router、Taro、TypeScript、等前端技术，能够根据项目需求选择合适的框架进行开发和优化。\r\n服务端技术：了解Nginx、Nodejs、Koa、Express、Java、Jsp、,Mongodb等服务端技术，能够进行简单的后台接口开发和数据处理。\r\n多终端开发：具备PC、移动端、微信/支付宝小程序、Webapp、Hybird App、可视化数据大屏，低代码平台等多种终端的开发经验，能够实现响应式设计、无障碍设计、SEO优化等功能，了解flutter技术。\r\n网络技术：熟悉HTTP、TCP/IP、WebSocket 等网络协议，了解浏览器工作原理，熟悉Linux操作。\r\n综合能力：对代码可维护性、组件易用性、前端性能优化、前端安全有实践经验。良好美术设计感，能够进行动画创意设计和实现；理解金融系统业务流程及管理系统开发要求；具备用户体验优化的意识和方法；良好的沟通和团队合作意识。\r\n\r\n\r\n**工作经历**\r\n◆ 公司名称：平安智慧城市 / 平安银行\t\t智慧生活i城市事业部\t\tWeb前端工程师（正编）\r\n◆ 工作时间：2018年10月-2022年12月\r\n1．项目经历：负责i城市部门“i深圳”“i东莞”等10多个智慧城市的项目，有市民app、深圳地铁app、“i城市”小程序、PC中后台运营管理系统，平安银行/小微商户支付渠道交易系统、大数据可视化配置平台，低代码平台，可视化H5搭建平台，多终端开发，小程序开发，项目文档沉淀、安全漏洞修复、风险预测，持续提升前端团队效率质量，项目owner\r\n2．架构设计：参与“i深圳”等城市项目前端部署架构设计优化，“i城市”开放平台、Hybrid交互方案设计，负责i深圳配置系统、积木系统（H5页面可视化配置系统）、活动模版系统、运营管理系统整体设计开发，角色及权限系统改造，并最终抽离为通用项目，支撑其他“i城市”项目快速复用\r\n3．技术沉淀：参与组内技术分享和专利申请，在内部进行前端性能优化、web动画设计原理及实践、可视化配置系统实践经验总结等多次团队分享，和《web曲线动画》、《手写图形验证码技术》、《DOM自动生成CSS语法树》的专利申报\r\n4．效率化工具：Node开发打包程序、发布接口、自动化部署脚本，Nginx配置、缓存配置、UI组件库开发\r\n\r\n◆ 公司名称：腾讯IEG游戏平台部 / 腾讯CDC 用户研究与体验设计中心\t Web前端工程师（正编）\r\n◆ 工作时间：2014年9月-2018年9月\r\n1．IEG移动游戏社区app的开发，PC游戏社区开发，运营平台开发，WeGame客户端内的业务开发，PC游戏、王者荣耀等游戏活动H5和嘉年华活动开发。\r\n2．腾讯人工智能实验室：承担主要的前端开发，包括数据可视化平台搭建、AI翻译、AI同声传译、AI图像识别、AI医疗等技术成果的项目转化，讨论提出交互实现方案，可行性分析，成果落地。\r\n3．负责并推进项目落地：用户画像标签系统、AI Lab、广点通、安全平台、IT/行政/财经线OA业务开发。前端代码编写，需求沟通，分析排期，交互视觉等功能的可行性评审；项目规范制定，供应商团队管理；前后端API对接。\r\n◆ 主要参与项目例举： \r\n游戏相关项目：WeGame平台业务开发，各个游戏专属主题社区开发，移动社区app手游宝的开发，数据运营平台开发\r\n微信小程序项目：数字广东“粤省事”微信小程序(PV1000W+)、AI寻画作诗、AI滤镜大师、AI画师YUI\r\n官网项目：腾讯AI官网、腾讯投资官网、腾讯云搜索及管理后台、腾讯语义分析NLP官网、内部门户/知识库\r\n管理后台项目：用户画像标签系统、腾讯云硬盘管理CBS项目、数字广东网厅AI客服、魔方大数据计算平台\r\n移动端项目：微信无现金日(PV500w+)、历年圣诞晚会抽票、行政助手、访客系统、腾讯餐厅\r\n部分H5与小程序demo：https://www.tuziki.com/demo/dist/\r\n\r\n◆ 公司名称：深圳市思迪信息技术有限公司  UEDC用户体验设计中心\t  Web前端工程师（正编）\r\n◆ 工作时间：2013年- 2014年\r\n◆ 工作描述：主要负责公司金融、银行、证券类产品的前端，UI交互，PC管理系统/H5系统开发，微信、微博类工作平台工作；光大证券、华泰证券、长江证券工作平台、中投证券工作平台、华龙证券微博平台的管理后台及管网。\r\n\r\n◆ 公司名称：百度湖北分公司\t  武汉百捷技术部    Web前端工程师（正编）\r\n◆ 工作时间：2012年- 2013年\r\n◆ 工作描述：主要从事中小型企业网站、门户、商城前端页面，交互效果开发，用户体验优化，页面性能兼容优化，移动端H5系统/UI页面开发，参与统一前端编码规范的制定，加快前端开发效率；\r\n\r\n\r\n**项目经历**\r\n平安智慧城项目：积木系统（页面可视化配置系统）\r\n项目介绍：积木系统是一个可视化页面配置系统，旨在产品、运营人员通过系统自由拖拽组合组建生成UI设计的政务服务页面或者运营活动页面\r\n技术栈：前端：Vue + Vuex + Vue-router + Element UI\t\t后台：NodeJs + Koa + Sqlite\r\n1.职责描述：作为项目开发人员参与系统后台接口、前端页面、组建开发设计，版本迭代、开发文档整理，抽离出基线版本，并在多个项目总落地上线\r\n2.组件：基于Vue开发由JSON文件描述的UI组件库，解决组件的灵活更新，可视化配置\r\n3.安全：基于Node的Middleware在接口层控制用户权限、记录操作日志、文件类型校验；数据定期自动备份机制，防止数据意外丢失\r\n4.数据通讯：基于PostMessage和Vuex的状态管理，实现编辑、预览间数据的双向同步，解决可视化配置的实时预览问题\r\n5.动态数据：开发adaptor（接口适配器）支持数据源配置中支持插入代码片段，进行API调用、数据清洗转换，实现动态获取数据，解决咨询类、列表类组建动态获取数据\r\n6.渲染：模版页面通过Vue的use方法将组建库中的组建在全局导入，然后通过API接口获取页面配置JSON，转换后更新到state中，根据当前页面Id从JSON中获取当前页的页面信息、组建列表、组建数据、组建样式，调用渲染引擎（VTree）进行组建渲染\r\n7.事件：基于Vue的混入（mixins）在组建内统一处理事件逻辑，根据事件类型，实现url跳转、子页面切换、Hybrid交互、数据埋点、电话拨号、跳转地图、登陆判断、刷脸认证、实名认证、跳转小程序等\r\n8.自动化运维：基于NodeJs开发完整的变更预览、灰度验证、上线、站点下线流程，解决人肉运维问题；docker容器化部署实现项目快速迁移上线\r\n![](https://www.tuziki.com/post-images/1683370710080.png)\r\n\r\n平安智慧城市项目：大数据可视化配置监控平台   \r\n项目介绍：实现数据可视化配置，选择所需的数据图表类型，接入数据源，展示一个整体的数据监控页面，主要用来展示城市项目中的各种数据，比如：用户新增/活跃、移动设备类型、公共危机事件统计、政府单位服务处理数量、社会基建及投诉数据\r\n技术栈：react、redux、dva、antdesign、router、webpack、umi\r\n1、职责描述：项目整体的研发和进度把控，设计数据交互逻辑图，拟定开发规范和新增分支子项目的对接文档，编码实现并迭代版本，项目已经在6个城市中有落地上线。\r\n2、规则：与后台开发一起拟定数据上报的规则，用户自定义页面组件与数据库的数据通信规范，以及进行信息交换的约定协议。\r\n3、组件：基于BizChart再次封装一套适用于本项目的富组件图表库（折线、柱状、饼图、热点、散点等），解决数据图表多样性及可动态配置的问题\r\n4、框架：基于react antdesign搭建基础页面，并封装成UI组件，单个的子组件和页面组件框架。并植入用户权限树、角色权限树、菜单权限树等公共管理端模块的功能\r\n5、动态配置：JSON由可视化编辑器来生成，用户选择新页面所用的基础UI模板、数据操控组件、数据展示组件、并接入对应的数据源（上传excel、api接口、手动录入），最终生成配置JSON文件与用户信息存入数据库，并同步刷新视图，解决管理后台动态可配置\r\n6、通信渲染：页面层根据导入JSON定义的组件类型和数据来渲染页面及组件模块，组件模块再通过中间的模板解析层渲染映射封装过的富组件及子组件。父页面/组件等待子页面/组件加载成功后，发送最新版本的state给子页面进行初始状态渲染。子页面/组件之间通信用redux进行数据共享和通信，子页面/组件store状态变化时将最新的state发送给父页面，以便父页面/组件及时同步状态，解决数据通信与数据可同步\r\n![](https://www.tuziki.com/post-images/1683370838874.png)\r\n![](https://www.tuziki.com/post-images/1683379089773.png)\r\n\r\n平安银行：统一支付平台商户渠道交易管理系统\r\n项目介绍：小微商户登记，商家入驻平台，注册，校验，以及多种交易方式记录的归集处理\r\n技术栈：react、redux、dva、antdesign、router、webpack\r\n1、职责描述：在银行开发半年，对接银行端后台系统，负责业务员、商户巡检、商户进件、角色权限等模块的增删改查及整合，以及部分银行业务型组件的封装，文件流的处理\r\n2、组件层：自定义业务型组件封装，银行数据选择器组件根据传入的全国银行列表数据，通过redux方式封装数据，通过分页请求方式来优化数据量过大的问题，且提供搜索功能；用户角色权限树组件，通过分析数据层级嵌套三层递归请求，渲染树形数据，并提供选择功能；富表单校验组件，业务中多种表单控件的输入数据格式，整理成公共的校验函数，在使用时导入，传入校验格式及数据\r\n3、协作：主动推动后台、测试、及产品层面的问题。并做基础框架搭建及优化。整合不同开发者的多个模块的代码。\r\n4、安全性：前端进行表单校验，屏蔽非正常数据防止XSS注入，对数据进行前后端的双脱敏措施\r\nPC端：\r\n![](https://www.tuziki.com/post-images/1683374644986.png)\r\n移动端：\r\n![](https://www.tuziki.com/post-images/1683374186123.png)\r\n<!-- \r\n| |\r\n|:-|:-:|:-:|-:|\r\n-->\r\n平安智慧城市项目：“i城市”市民通Hybird app   \r\n项目介绍：10多个城市级的市民服务app，涵盖社保、医疗、公积金、交通、出入境、教育等服务\r\n技术栈：vue、vuex、router、vant、webpack、react、JSSDK\r\n1、职责描述：项目owner，需求分解排期，业务开发。业务组件和公共组件的编写，并丰富团队的UI组建库\r\n2、开发方式：H5方式，也会用到html离线包和react native技术。调用并封装客户端提供的SDK，使用原生app方法来完成一些业务开发。活动模板配置化开发，前后端数据脱敏加解密。\r\n3、框架及部署：搭建基于vue、react基础框架，优化移动端的加载性能，以及多种方式的部署上线\r\n![](https://www.tuziki.com/post-images/1683375973229.png)\r\n\r\n平安智慧城市项目：PC端后台运营与中台管理系统\r\n项目介绍：与移动端市民通项目配套的后台管理系统\r\n技术栈：react、redux、dva、antdesign、router、webpack\r\n1、职责描述：负责项目搭建、中台权限控制、用户权限模块、角色权限树、菜单导航模块、app内容更新配置、小程序内容更新配置，系统等模块的整合，版本迭代、新增业务模块开发。\r\n2、性能优化：页面加载的性能优化，用户使用体验优化，主要在登录校验、页面报错提示、文件流下载、打包后的主文件过大进行拆包分解加载，提高页面的渲染速度，等方面的优化\r\nAPP后台运营管理系统：\r\n![](https://www.tuziki.com/post-images/1683376080536.png)\r\n数据中台：\r\n![](https://www.tuziki.com/post-images/1683376261457.png)\r\n![](https://www.tuziki.com/post-images/1683378792097.png)\r\n\r\n平安智慧城市项目：“i城市”数字城市类小程序\t\r\n项目介绍：城市市民通服务的微信小程序版，以及支付宝小程序版本\r\n技术栈：Taro、react、微信小程序开发、支付宝小程序开发\r\n1、职责描述：主要负责小程序的业务代码、核心页面、组件开发，需求逻辑规划设计，用户个人中心模块，页面热更新模块\r\n2、用户认证：实名及登录验证流程梳理，人脸及实名认证登录开发\r\n3、业务开发：数据展示，第三方委办局业务对接，数据上报\r\n4、性能优化：前端代码的函数进行解耦，降低耦合度，考虑数据异常、接口异常、网关异常等多种情况提高代码在异常情况下的容错率、提高程序健壮性。\r\n5、体验优化：从多种角度出发，模拟用户未登录、未实名、未登记信息、账户互踢等多种情况下的体验，来验证整个产品的交互逻辑是否完整闭环，优化流程校验。\r\n![](https://www.tuziki.com/post-images/1683376976989.png)\r\n\r\n腾讯-游戏社区平台及WeGame客户端开发\r\n项目介绍：腾讯游戏平台，包括PC端游戏和移动端手游社区，WeGame游戏客户端内部模块开发，运营活动开发\r\n技术栈：Electron、vue、vuex、css3动画，canvas动画，骨骼动画，帧动画\r\n责任描述：平台社区开发，游戏wiki搭建并拓展了权限管理、审核管理、发布预览功能。手游宝app内部模块开发。\r\n王者荣耀等游戏的运营活动开发，领取礼包，签到，积分活动，并开发其中的动画效果和数据逻辑交互过程。\r\nWeGame客户端中内嵌的游戏专题模块，英雄数据资料，场景资料，游戏相关资料模块的业务前端开发。\r\n![](https://www.tuziki.com/post-images/1683377272872.png)\r\n\r\n腾讯-用户画像标签分析系统\r\n项目介绍：一套可配置化的表单引擎，创建用户画像、用户标签、标签分群、用户分群等分析模式的配置化表单来分析用户数据。根据不同的标签属性和类别，操作对应类型数据组做配置选择，存在比较复杂的关联关系，开发过程中有表单数据流和逻辑关联等较复杂的操作。最终，用数据图表做最终呈现，柱状图，饼图，历史数据折线图等。\r\n技术栈：react、dva、redux、antdesign、router、webpack\r\n1、职责描述：项目的核心开发、需求讨论，前端团队技术指导，代码规范约束，对前端代码质量负责，整体进度把控\r\n2、组件库：用antdesign UI组件库为基础，手动开发一些特异性表单组件，定制表单校验及个性化表单控件，使用dva，redux，store, dispatch控制多模块之间的数据流交换，定制开发一些数据图表。\r\n3、项目管理：沟通产品经理所用组件的UI及交互操作，与后端开发拟定前端API接口定义，项目团队管理、需求排期汇报。\r\n![](https://www.tuziki.com/post-images/1683377526511.png)\r\n\r\n腾讯-数字广东项目：粤省事微信小程序、广东省网上政务服务大厅、智能对话客服\r\n项目介绍：广东省政务服务，民生小程序，集成社保、公积金、出入境多种功能，需要协调多家供应商参与开发不同业务分支小程序，再整合功能，打包发布\r\n技术栈：微信小程序模块化，自定义组件、插件开发、实名认证流程\r\n1、职责描述：负责粤省事整体小程序的UI组件库，主页面开发，部分子业务的开发，涉及到用户多种身份、多种证件状态的逻辑判断，数据卡片渲染及公共模块，个人中心，slot插件等内容的开发\r\n2、文档管理：整理项目需求文档、代码规范、UI组件库文档、封装的API接口文档\r\n3、项目管理：规范开发流程，把控8家供应商的代码输出质量，按照代码规范CodeReview，走查UI细节、Js的逻辑漏洞、部分通过构建工具定制Eslint来检查判断语句的函数圈复杂度，公共变量的使用污染等问题，大团队QA解答工作\r\n![](https://www.tuziki.com/post-images/1683378290866.png)\r\n\r\n腾讯云CBS云硬盘管理系统  \r\n项目介绍：腾讯云及TEG基础架构部开发的一套云硬盘管理系统\r\n技术栈：sass、vue、vuex、webpack、es6、Element UI \r\n1、职责描述：搭建开发腾讯云服务器硬盘管理系统，用于服务器硬盘的裁撤，上架，管理等操作。负责项目前端进度的规划，前端工程搭建，具体业务开发，API接口格式定义，接口对接，业务流程CUDR，跨部门合作的进度把控，模块整合。\r\n\r\n腾讯-供应商团队管理   \r\n工作内容：管理4家供应商，制定评分定级规则。在立项阶段评估时间与效率，制定时间节点确定流程与规范。过程阶段跟进服务与沟通，流程进度把控、Code Review。交付阶段把控质量与检测，制定阶段性交付计划、项目定稿邮件规范。\r\n评分规则：完成质量、视觉还原程度、代码规范、兼容性适配、性能优化、XSS安全、服务态度、沟通响应频率、是否延期。\r\n\r\n**过往荣誉**\r\n◆ 2016年腾讯微创新奖-自助访客机系统（公司级专业奖）\r\n◆ 2016、2017年腾讯CDC用户研究与体验设计部即时激励奖（部门级）\r\n◆ 2018年腾讯业务突破奖-数字广东项目（公司级业务突破奖）\r\n◆ 2018年腾讯TEG事业群优秀讲师（事业群级）\r\n◆ 2019年平安智慧城市优秀讲师（公司级）\r\n\r\n<!-- \r\n### 捉虫小技\r\n| 项目名 | 访问地址   | 技术栈 | 备注 |\r\n| ----- | --------- | ------ | ------- |\r\n| Find | <a href=\"http://souxy.com/map.html\" target=\"_blank\">souxy.com/map.html</a> | 腾讯地图API |已知N(N>=2)个A点坐标和距离(L>=2)，求B点坐标|\r\n| 加班计时器  | <a href=\"http://souxy.com/clock\" target=\"_blank\">souxy.com/clock</a>     | vue |加班倒计时工具|\r\n| 工作日历 | <a href=\"https://we.joox.cc\" target=\"_blank\">we.joox.cc</a>     | vue+koa+nodejs+mongoDB |个人工作管理、团队管理系统|\r\n\r\n### 专业能力\r\n\r\nUI开发能力：html5、css3、less、sass、bootstrap、svg、canvas；\r\n\r\n前端构建技术：gulp、swig、webpack、svn、git\r\n\r\n框架（库）技术：vue、react、jquery、TypeScript、es567、组件化\r\n\r\n服务端技术：Nodejs、Java、SQL、<del>Python、MongoDB、MYSQL</del>\r\n\r\n多终端开发：PC、移动端、微信小程序、webapp、Hybird app、响应式设计、无障碍设计、SEO优化\r\n\r\n较好的美术设计感、UI重构、动画创意设计与开发实现能力（css3、svg、apng、canvas、webgl）；\r\n\r\n较好的金融系统业务理解能力及后端管理系统开发能力；\r\n\r\n较好的用户体验设计与开发能力；\r\n\r\n\r\n### 工作经历\r\n\r\n湖北百度 => 企业OA系统及网站系统开发\r\n\r\n深圳思迪 => 金融账户及业务系统开发\r\n\r\n深圳腾讯 => 互娱游戏平台 & 用户研究系统 & AI工程化建设\r\n\r\n深圳平安 => 平安小微商户平台渠道系统开发，以及和一群可爱的人为人民写代码\r\n\r\n### 我的爱好\r\n乒乓球、羽毛球、以及众多的小球类运动，游泳爬山可还行，种花草，撸猫撩狗，打王者吃鸡。\r\n -->\r\n\r\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r\n\r\n<!-- more -->\r\n\r\n[Github](https://github.com/getgridea/gridea)  \r\n[Gridea 主页](https://gridea.dev/)  \r\n[示例网站](http://fehey.com/)\r\n\r\n## 特性👇\r\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \r\n\r\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \r\n\r\n🏷️  你可以对文章进行标签分组  \r\n\r\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \r\n\r\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \r\n\r\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \r\n\r\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \r\n\r\n🇬🇧  你可以使用**中文简体**或**英语**  \r\n\r\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \r\n\r\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \r\n\r\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\r\n\r\n未来，它一定会成为你离不开的伙伴\r\n\r\n尽情发挥你的才华吧！\r\n\r\n😘 Enjoy~\r\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": true,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \r\n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \r",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "mongodb",
      "slug": "MGpi3VOtt",
      "used": true
    },
    {
      "name": "算法",
      "slug": "pE2yIQ8qr",
      "used": true
    },
    {
      "name": "小项目",
      "slug": "At2AiqZw3",
      "used": true
    },
    {
      "name": "Nginx",
      "slug": "aOqOChIeK",
      "used": true
    },
    {
      "name": "抓包",
      "slug": "iI4BJ6jlg",
      "used": true
    },
    {
      "name": "正则",
      "slug": "R5GbvRTcO",
      "used": true
    },
    {
      "name": "Array",
      "slug": "QOEdciYBP",
      "used": true
    },
    {
      "name": "Linux",
      "slug": "2duN4ViXj",
      "used": true
    },
    {
      "name": "代码优化",
      "slug": "OJwoHNe94",
      "used": true
    },
    {
      "name": "SEO",
      "slug": "8DvZwLPY4",
      "used": true
    },
    {
      "name": "react",
      "slug": "8bhxgbENH",
      "used": true
    },
    {
      "name": "递归",
      "slug": "3JETxJuGKV",
      "used": true
    },
    {
      "name": "数组",
      "slug": "AfdhbYEZH",
      "used": true
    },
    {
      "name": "js时间处理",
      "slug": "js-shi-jian-chu-li",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "rTDiJ0rIZ",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "index": 1,
      "link": "/archives",
      "name": "码字",
      "openType": "Internal"
    },
    {
      "index": 3,
      "link": "/project",
      "name": "小项目",
      "openType": "Internal"
    },
    {
      "index": 3,
      "link": "/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}